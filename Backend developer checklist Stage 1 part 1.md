# Backend developer checklist (все по ООП, подчернутые в приоритете)

****************************************************************************
## Stage 1, part 1 
## ООП
Вопросы в этом разделе:
  * Статическое поле/метод.
  * Инкапсуляция; модификаторы доступа: public, private, protected; свойство класса (геттер, сеттер).
  * Наследование, Абстрактный класс.
  * Ассоциация, Агрегация, Композиция, разница между ними.
  * Плюсы и минусы наследования. В каких случаях стоит применять композицию, а в каких наследование, при проектировании. (привести пример сравнения)
  * Основное назначение интерфейсов. Полиморфизм подтипов.
  * Множественное наследование, проблема ромбовидного наследования. Наследование через интерфейсы, делегирование.
  * Связность, связанность. Как повысить связность, как понизить связанность? Декомпозиция.
  * UML диаграмма классов.
****************************************************************************

### Объект 
**Объект** — это **именованная сущность**, одновременно содержащая данные(свойства) и поведения(методы).
Слово «одновременно» в данном случае определяет ключевую разницу между ООП и 
другими методологиями программирования. Например, при процедурном программировании 
код размещается в полностью отдельных функциях или процедурах.

**КЛАСС** - это шаблон, предназначенный для создания объектов.
Класс - это именованная сущность из предметной области, возможно, имеющая 
предка (суперкласс), определенная как набор полей и методов.

**КЛАСС** - это шаблон (blueprint), используя который мы можем создавать экземпляры объектов, у которых будет точно такая же конфигурация, как и у шаблона — те же свойства и методы. **ИНТЕРФЕЙС** — это группа взаимосвязанных свойств и методов, которые описывают объект, 
но не обеспечивают реализацию или инициализацию этих свойств и методов в объектах.
Классы можно определять через объявление (declaration) или выражение (expression). 
Важное отличие: объявление класса, в отличие от объявления функции, не 
поднимается (not hoisted).

В JS производный класс - это НЕ независимая копия родительского класса. Первый связан с последним через prototype. Изменения в prototype передаются производным классам после инициализации.
В JavaScript классы можно организовать по-разному. Говорят, что класс User написан 
в «функциональном» стиле. Далее мы также увидим «прототипный» стиль.

****************************************************************************
### Статическое поле/метод.
https://learn.javascript.ru/static-properties-and-methods
https://code-examples.net/ru/q/176e8f

СТАТИЧЕСКОЕ ПОЛЕ хранит данные, специфичные не для одного объекта, а для всего класса  целиком. Как правило это константы.

`private static instance: Config;`

СТАТИЧЕСКИЙ МЕТОД: 
  * не использует состояние объекта и использует свойства, передаваемые в параметрах.
  * Статический метод также можно использовать для функций, которые вообще не требуют наличия объекта. Например, просто форматируем передаваемую дату.
  * Статический метод определяется ключевым словом static.

`static staticMethod() { return 'Вызван статический метод'; }`

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes/static

`class StaticMethodCall {`
`  static staticMethod() {`
`    return 'Вызван статический метод';`
`  }`
`  static anotherStaticMethod() {`
`    return StaticMethodCall.staticMethod() + ' из другого статического метода';`
`  }`
`}`
`StaticMethodCall.staticMethod();  //  'Вызван статический метод'`

`StaticMethodCall.anotherStaticMethod();  //  'Вызван статический метод из другого статического метода'`

Статические методы недоступны через ключевое слово this из нестатических методов. Нужно вызвать их с помощью имени класса: 

```CLASSNAME.STATIC_METHOD_NAME()``` 
или вызовом метода как свойства конструктора: 
```this.constructor.STATIC_METHOD_NAME()```.

class StaticMethodCall {
  constructor() {
    console.log(StaticMethodCall.staticMethod()); 
    // 'вызван статический метод.' 

    console.log(this.constructor.staticMethod()); 
    // 'вызван статический метод.' 
  }

  static staticMethod() {
    return 'вызван статический метод.';
  }
}

class Triple {
  static triple(n) {
    if (n === undefined) {
      n = 1;
    }
    return n * 3;
  }
}

class BiggerTriple extends Triple {
  static triple(n) {
    return super.triple(n) * super.triple(n);
  }
}

console.log(BiggerTriple.triple(3));
// 81 (не затрагивается экземпляром родителя)

console.log(tp.triple());
// Выведет сообщение, что "tripple" не является
// функцией ('tp.tripple is not a function').


В ECMAScript 6 вы можете создавать статические функции, используя ключевое слово static :
class Foo {
  static bar() {return 'I am static.'}
}

//'bar' is a property of the class
Foo.bar() // returns 'I am static.'

//'bar' is not a property of instances of the class
var foo = new Foo()
foo.bar() //-> throws TypeError


`class MyClass {
    constructor() {
        this._privateVariable = "Private variable";  // Private variable 
        this.publicVariable = "Public variable";  // Public variable 
    }
    get privateVariable() {
        return this._privateVariable;
    };
    set privateVariable(val) {
        this._privateVariable = (val < 0) ? 0 : val;
    };
}`


****************************************************************************
### ИНКАПСУЛЯЦИЯ; 
модификаторы доступа: public, private, protected; свойство класса (геттер, сеттер).
*
Зачем ? Как применять ?  
Зачем нам надо связывать данные и методы внутри класса ? Кроме закрытия от пользователя.

**ИНКАПСУЛЯЦИЯ** - это Объединение атрибутов и методы в одной сущности/классе и скрытие 
от пользователя класса части свойств и методов, а также способов реализации 
функциональности класса.
При проектировании класса определяем что в классе должно быть видно, а что — нет. 
При хорошем объектно-ориентированном проектировании объект должен показывать только 
интерфейсы, необходимые другим объектам для взаимодействия с ним. 
Детали, не относящиеся к использованию объекта, должны быть скрыты от всех 
других объектов.

**ИНКАПСУЛЯЦИЯ** обеспечивает модульность (все в одном месте)  и облегчает переиспользование (наследование и композиция), сопровождение и рефакторинг.

ИНКАПСУЛЯЦИЯ позволяет нам управлять доступом к данным в объекте. 
Клиентский код видит только интерфейс (публичные методы), а разработчики могут изменить реализацию не затронув клиентский код.

Для того, чтобы скрытие данных произошло, все атрибуты должны быть объявлены как 
private. Поэтому атрибуты никогда не являются частью интерфейсов. Частью 
интерфейсов классов могут быть только открытые методы. Объявление атрибута как public нарушает концепцию скрытия данных.

* public — доступ к типу или члену возможен из любого другого кода в той же
сборке или иной сборке, которая на него ссылается - у других объектов будет к нему 
прямой доступ;
* private — доступ к типу или члену возможен только из кода в том же классе или
структуре;
* protected — доступ к типу или члену возможен только из кода в том же классе
или структуре или в производном классе;

private
Когда тип данных или метод определен как private, только код этого объекта
сможет получить к нему доступ. 

public class IntSquare {
// закрытый атрибут
private int squareValue;
// открытый интерфейс
public int getSquare (int value) {
  SquareValue = calculateSquare(value);
  return squareValue;
}
// закрытая реализация
private int calculateSquare (int value) {
  return value*value;
  }
}
Следует отметить, что единственной частью класса, доступной для пользовате-
лей, является открытый метод getSquare , который относится к интерфейсу. 
Реализация алгоритма вычисления квадратов чисел заключена в закрытом методе
calculateSquare. Обратите также внимание на то, что атрибут SquareValue 
является private.
объект показывает только интерфейсы, необходимые пользователям для взаимодействия 
с ним, а детали, не относящиеся к использованию объекта, скрыты от других объектов.

protected

Ассоциация, Агрегация и Композиция НЕ позволяют обращаться к методам protected

#### ГЕТТЕРЫ И СЕТТЕРЫ
Концепция геттеров и сеттеров поддерживает концепцию скрытия данных. Поскольку другие объекты 
не должны напрямую манипулировать данными, содержащимися в одном из объектов, геттеры и сеттеры 
обеспечивают управляемый доступ к данным объекта. Геттеры и сеттеры иногда называют методами доступа и методами-модификаторами соответственно.
Геттеры и сеттеры в действительности являются свойствами атрибутов — например, 
свойство get атрибута с именем Name.

```
Private string strName;
public String Name {
  get {
  return this.strName;
  }
  set {
  if (value == null) return;
  this.strName = value;
  }
}
```

#### СООБЩЕНИЯ
Сообщения — это механизм коммуникаций между объектами. Например, когда
объект А вызывает метод объекта В, объект А отправляет сообщение объекту В.
Ответ объекта В определяется его возвращаемым значением. Только открытые,
а не закрытые методы объекта могут вызываться другим объектом.

Во многих ситуациях будут попадаться методы, которые также должны быть
скрыты и, таким образом, не являться частью интерфейса. Это прозволит 
разрабочику заменить алгоритм (возможно, потому, что новый алгоритм оказался 
более эффективным), что не повлияет при этом на пользователей разработанных 
классов/интерфейсов.

ПОДПИСИ: ИНТЕРФЕЙСЫ В СОПОСТАВЛЕНИИ С ИНТЕРФЕЙСАМИ
Важно отметить, что существуют интерфейсы как для классов, так и для методов, 
поэтому не путайте их. Интерфейсы классов — это открытые методы. Их вызов 
осуществляется при использовании их подписи, которая главным образом состоит 
из имени метода и списка его параметров.


****************************************************************************
### Наследование, Абстрактный класс.
*
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes/extends

#### НАСЛЕДОВАНИЕ - получение по наследству атрибутов и поведений от родительского класса.

**КЛАСС** - это шаблон (blueprint), используя который мы можем создавать экземпляры 
объектов, у которых будет точно такая же конфигурация, как и у шаблона — те же свойства и методы. 

Наследование: класс может унаследовать — использовать по умолчанию — поля и методы своего предка. 
Класс может наследовать от другого класса и использовать атрибуты и методы своего предка. 

НАСЛЕДОВАНИЕ подразумевает получение по наследству атрибутов и поведений от родительского класса/классов.
При этом имеет место настоящее отношение «родительский класс/дочерний класс». Дочерний класс (или 
подкласс) наследует напрямую от родительского класса (или суперкласса).

Синяя книга по Smalltalk описывает наследование исключительно с точки зрения наследования реализации:
«Подкласс определяет, что все его экземпляры будут, за исключением явно указанных отличий, такими же, 
как экземпляры другого класса, называемого его суперклассом».
Обратите внимание на отсутствующую деталь: не упоминается, что экземпляр подкласса должен быть в 
состоянии заменить экземпляр суперкласса везде в программе; не упоминается, что экземпляр подкласса 
должен удовлетворять всем концептуальным тестам для экземпляра своего суперкласса.

Наследование характеризуется отношением «является экземпляром».

Ключевое слово extends используется в объявлении класса или в выражениях класса 
для создания дочернего класса.

class Square extends Polygon {
  constructor(length) {
    super(length, length);
    this.name = 'Square';
  }

Метод Object.create() создаёт новый объект с указанными объектом прототипа и свойствами.
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/create

Класс может наследоваться от другого класса, который наследуется от третьего, и так далее вплоть до базового класса (обычно — Object), возможно, неявного. Наследник может переопределить какие-то методы и поля чтобы изменить поведение по умолчанию.
Берем класс, который нас почти устраивает и через переопределение части методов 
(функциональности) или через композицию создаем нужного нам потомка.
Не копи-пастим больших кусков кода.

Наследование в JS построено на прототипах.
При структурном проектировании повторное использование кода допускается в известной мере: 
вы можете написать процедуру, а затем применять ее столько раз, сколько пожелаете.
Однако объектно-ориентированное проектирование делает важный шаг вперед,
позволяя вам определять отношения между классами, которые не только облегчают 
повторное использование кода, но и способствуют созданию лучшей общей
конструкции путем упорядочения и учета общности разнообразных классов.
Основное средство обеспечения такой функциональности — наследование.
Наследование позволяет классу наследовать атрибуты и методы другого класса.
Это дает возможность создавать абсолютно новые классы путем абстрагирования
общих атрибутов и поведений.
Суперкласс, или родительский класс (иногда называемый базовым), содержит все
атрибуты и поведения, общие для классов, которые наследуют от него.
Подкласс, или дочерний класс (иногда называемый производным), представляет 
собой расширение суперкласса.

#### Абстрагирование
Абстрагирование означает выделение значимой информации и исключение из рассмотрения 
незначимой (для данного проекта):
  - важна возможность переиспользования в будущем
  - абстракции помогают в работе со сложным
  - Позволяет представить сложную реальность в виде упрощённой модели


#### АБСТРАКТНЫЙ КЛАСС — это класс, у которого не реализован один или больше методов (абстрактные методы). 
Если подкласс наследует абстрактный метод от суперкласса, то он должен обеспечивать конкретную реализацию этого метода, поскольку иначе он сам будет абстрактным классом.

Абстрактный базовый класс описывает некоторое семейство типов, но помимо декларации операций может содержать реализации по умолчанию (виртуальные методы) и фиксированные операции (невиртуальные методы).

Абстрактный класс нужен, когда нужно семейство классов, у которых есть много общего. Конечно, можно применить и интерфейс, но тогда нужно будет писать много идентичного кода (переопределять все методы, а не наследовать уже готовые).

В некоторых языках (С++) специального ключевого слова для обозначения интерфейсов нет.
Можно считать, что любой интерфейс — это уже абстрактный класс, но не наоборот.

Конкретный класс описывает некоторое семейство типов, которое готово для использования клиентами. Такой класс не может содержать декларации операций и все его операции должны быть либо фиксированными (невиртуальные методы) или содержать реализацию по умолчанию (виртуальные методы). 
Есть еще один подвид конкретных классов – запечатанный (**sealed**) класс – это разновидность конкретного класса отнаследоваться от которого невозможно, а значит он может содержать лишь конкретные операции.

Допустим, у вас есть абстрактный класс Shape. Он является абстрактным потому, что 
у него есть абстрактный метод draw() и нельзя создать экземпляр класса Shape.



В UML-диаграмме
знак плюса ( + ) обозначает public , а знак минуса ( – ) указывает на private
знак решетки ( # ) обозначает Protected

Под абстрагированием мы подразумеваем изоляцию непереносимого кода
в его собственном классе или по крайней мере в его собственном методе (который
может быть переопределен). Например, если вы пишете код для доступа к после-
довательному порту определенного аппаратного обеспечения, то вам следует создать
класс-обертку для работы с ним. Ваш класс затем должен будет отправить сообще-
ние классу-обертке для получения информации и услуг, которые ему нужны.

Object.setPrototypeOf()
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf



****************************************************************************
### Ассоциация, Агрегация, Композиция, разница между ними.
*
Пояснения
http://sergeyteplyakov.blogspot.com/2012/12/vs-vs.html
https://habr.com/post/150041/
https://habr.com/post/354046/

Ассоциация, Агрегация и Композиция НЕ позволяют обращаться к методам protected.

#### АССОЦИАЦИЯ (association) 
означает, что два класса как-то связаны между собой, 
и мы пока не знаем точно, в чем эта связь выражена и собираемся уточнить ее в 
будущем. Обычно это отношение используется на ранних этапах дизайна, чтобы 
показать, что зависимость между классами существует, и двигаться дальше.

АССОЦИАЦИЯ означает отношение между классами объектов, которое позволяет одному 
экземпляру объекта вызвать другого, чтобы выполнить действие от его имени. 
Это структурное отношение, поскольку определяет связь между объектами одного 
рода и объектами другого рода и не моделирует поведение.

Ассоциация – это когда один класс включает в себя другой класс в качестве одного из 
полей. Ассоциация описывается словом «имеет». Автомобиль имеет двигатель. Вполне 
естественно, что он не будет являться наследником двигателя (хотя такая архитектура 
тоже возможна в некоторых ситуациях). 

#### АГРЕГАЦИЯ (aggregation)
АГРЕГАЦИЯ подразумевают методику создания нового класса из уже существующих классов 
путём их включения в свой состав. Составная часть передается через параметры конструктора. 
Об агрегировании также часто говорят как об «отношении принадлежности» по принципу 
«у машины есть корпус,  колёса и двигатель».
Пожалуй, наиболее интуитивно понятной формой композиции является агрегация.
Агрегация означает, что сложный объект состоит из других объектов.

class Professor;

class Department
{
  private:
    Professor* members[5];  // Aggregation, т.к. нет оператора delete 
};
class Ehe // Пример агрегации
{
private:
    Person& _partner1; // Enthaltener Teil.  // Aggregation
    Person& _partner2; // Enthaltener Teil.  // Aggregation
 
public:
    // Конструктор
    Ehe (Person& partner1, Person& partner2)
        : _partner1(partner1), _partner2(partner2)
    { }
};

#### КОМПОЗИЦИЯ (composition)
Композиция (агрегирование по значению) — более строгий вариант агрегирования, когда 
включаемый объект может существовать только как часть контейнера. 
Если контейнер будет уничтожен, то и включённый объект тоже будет уничтожен.
Композиция подразумевает создание объектов с использованием других объектов.

Наследование характеризуется отношением «является экземпляром», 
а композиция — отношением «содержит как часть».

Например, автомобиль содержит как часть двигатель. Однако мы не можем сказать, что двигатель является экземпляром автомобиля.
Благодаря композиции мы к тому же можем создавать классы, вкладывая одни классы в другие.

Объекты содержат другие объекты. Объекты зачастую формируются или состоят из 
других объектов — это и есть композиция.
Композиция — индикатор использования отношения «содержит как часть». Когда наследование 
не оказывается правильным выбором при проектировании (из-за того, что отношение 
«является экземпляром» не подходит), обычно используется композиция.

Точно так же, как и наследование, композиция обеспечивает механизм для создания объектов. Фактически есть только два способа создания классов из других классов: наследование 
и композиция. Как мы уже видели, наследование позволяет одному классу наследовать от 
другого. Поэтому мы можем абстрагировать атрибуты и поведения для общих классов. 
Например, как собаки, так и кошки относятся к млекопитающим, поскольку собака является экземпляром млекопитающего так же, как и кошка. Благодаря композиции мы к тому же можем 
создавать классы, вкладывая одни классы в другие.
Для отношений композиции мы используем словосочетание «содержит как часть». Автомобиль содержит как часть двигатель. Однако мы не можем сказать, что двигатель является экземпляром автомобиля.

Во-первых, у класса Employee имеется ассоциация с классом Spouse. У работника может 
не быть супруга либо иметься один супруг (по крайней мере, в нашей культуре у работника 
не может быть более одного супруга). Таким образом, кардинальность этой ассоциации 
представлена как 0...1 .
Отношение между Employee и классом Division говорит о том, что каждый работник может быть ассоциирован с одним и только одним отделом. Это отношение представляет простая единица. Индикатор кардинальности выступает как очень важная часть объектной модели.


****************************************************************************
### Плюсы и минусы наследования. В каких случаях стоит применять композицию, а в каких наследование, 
при проектировании. (привести пример сравнения)
*
https://habr.com/post/177447/

Как наследование, так и композиция представляют собой механизмы **ПОВТОРНОГО ИСПОЛЬЗОВАНИЯ**.
Повторное использование объектов - главная причина существования наследования и композиции.

НАСЛЕДОВАНИЕ подразумевает получение по наследству атрибутов и методов (поведений) от родительского класса/классов.
При этом имеет место отношение «родительский класс/дочерний класс» - отношением «является экземпляром». Дочерний класс (или подкласс) наследует напрямую от родительского класса (или суперкласса).

КОМПОЗИЦИЯ
Композиция подразумевает использование других классов для создания более сложных классов, то есть для осуществления своего рода сборки. При этом нет никаких отношений «родительский класс/дочерний класс». 
Благодаря композиции мы к тому же можем создавать классы, вкладывая одни классы в другие.

#### ПРЕИМУЩЕСТВА композиции перед наследованием:
1. Нет конфликта имён, возможного при наследовании.
2. Возможность смены агрегируемого объекта в runtime.
3. Полная замена агрегируемого объекта в классах, производных от класса, включающего агрегируемый объект.

В последних двух случаях очень желательно, чтобы сменяемые агрегируемые объекты имели общий интерфейс. А в третьем – чтобы метод, возвращающий такой объект, был виртуальным.

#### минусы композиции:
1. Итак, если нам необходима возможность смены поведения извне, то композиция, по сравнению с наследованием, имеет принципиально другой тип отношений между объектом поведения и объектом, его использующим. Если при наследовании от абстрактного поведения мы имеем отношение 1:1, то при агрегации и возможности установки поведения извне мы получаем отношение 1:many. Т.е. один и тот же объект поведения может использоваться несколькими объектами-владельцами. Это порождает проблемы с общим для нескольких таких объектов-владельцев состоянием поведения.

2. Агрегация (и это, пожалуй, главный нюанс) отличается от наследования в первую очередь тем, что агрегируемый объект не является объектом-владельцем и не содержит информации о нём. Нередки ситуации, когда коду, взаимодействующему с поведением, необходим и сам объект-владелец (например, для получения информации о том, какими ещё поведениями он обладает).

В таком случае, нам придётся или передавать в такой код нетипизированный объект (как object или void*), или создавать дополнительный интерфейс для объекта-владельца (некий IBehaviorOwner), или хранить в поведении циклическую ссылку на объект-владелец. Понятно, что каждый из этих вариантов имеет свои минусы и ещё больше усложняет код. Более того, различные типы поведений могут зависеть друг от друга (и в это вполне допустимо, особенно если они находятся в некоем закрытом самодостаточном модуле).

3. Ну и последний минус — это конечно же производительность. Если объектов-владельцев достаточно много, то создание и уничтожение вместо одного объекта двух или более может не остаться незамеченным.

#### Как не надо наследовать. Пример 1

class Stack extends ArrayList {
    public void push(Object value) { … }
    public Object pop() { … }
}

Казалось бы, класс Stack, все хорошо. Но посмотрите внимательно на его интерфейс. Что должно быть в классе с именем Stack? Методы push() и pop(), что же еще. А у нас? У нас есть get(), set(), add(), remove(), clear() и еще куча барахла, доставшегося от ArrayList, которое стеку ну вообще не нужно.

Можно было бы переопределить все нежелательные методы, а некоторые (например, clear()) даже и адаптировать под наши нужды, но не многовато ли работы из-за одной ошибки в дизайне? На самом деле трех: одной смысловой, одной механической и одной комбинированной:


Утверждение "Stack это ArrayList" ложно. Stack не является подтипом ArrayList. Задача стека — обеспечить выполнение правила LIFO (последним пришел, первым ушел), которое легко удовлетворяется интерфейсом push/pop, но никак не соблюдается интерфейсом ArrayList.
Механически наследование от ArrayList нарушает инкапсуляцию. Клиентскому коду не должно быть известно, что мы решили использовать ArrayList для хранения элементов стека.
Ну и наконец, реализуя стек через ArrayList мы смешиваем две разные предметные области: ArrayList — это коллекция с произвольным доступом, а стек — это понятие из мира очередей, со строго ограниченным (а не произвольным)8 доступом.

Последний пункт — незначительная на первый взгляд, но важная вещь. Посмотрим на нее пристальнее.



****************************************************************************
### Основное назначение интерфейсов. Полиморфизм подтипов. 
*
https://habr.com/post/314258/

ИНТЕРФЕЙСЫ классов — это открытые методы. Их вызов осуществляется при использовании их 
подписи, которая главным образом состоит из имени метода и списка его параметров.

Должным образом сконструированные классы состоят из двух частей — интерфейса и реализации.
интерфейс включает синтаксис для вызова методов и возврата значений. Если интерфейс не претерпит
изменений, то пользователям будет все равно, изменится ли реализация.

ИНТЕРФЕЙС определяет основные средства коммуникации между объектами. При проектировании любого класса предусматриваются интер фейсы для надлежащего создания экземпляров и эксплуатации объектов. Любое поведение, которое обеспечивается объектом, должно вызываться через сообщение, отправляемое с использованием одного из предоставленных интерфейсов. В случае с интерфейсом должно предусматриваться полное описание того, как пользовате-
ли соответствующего класса будут взаимодействовать с этим классом. В большин-
стве объектно-ориентированных языков программирования методы, являющиеся
частью интерфейсов, определяются как public.

Если интерфейс спроектирован надлежащим образом, то изменения в реализации не должны требовать
внесения изменений в пользовательский код. Помните, что интерфейс включает синтаксис для вызова методов и возврата значений.

Интерфейс, в сущности, будет представлять собой интерфейс программирования
приложений (API — Application Programming Interface), который станут ис-
пользовать программисты. Соответствующие методы в действительности будут
обертками, в которых окажется заключена функциональность (, обеспечиваемая
системой баз данных).

Для каждого из приведенных ранее требований нам необходим метод, обеспе-
чивающий желаемую функциональность. Теперь нам нужно задать несколько
вопросов.
- Чтобы эффективно использовать этот класс, нужно ли вам, как программисту,
еще что-нибудь знать о нем?
- Нужно ли вам знать о том, как внутренний код базы данных открывает ее?
- Требуется ли вам знать о том, как внутренний код базы данных физически вы-
бирает определенную запись?
- Нужно ли вам знать о том, как внутренний код базы определяет то, остались ли
еще записи?
Ответом на все эти вопросы будет звучное «нет»! Вам не нужно знать что-либо
из этой информации. Вам важно лишь получить соответствующие возвращаемые
значения, а также то, что операции выполняются корректно.

Смысл ПОЛИМОРФИЗМА заключается в том, что вы можете отправлять сообщения разным объектам, 
которые будут отвечать на них в соответствии со своими объектными типами.
ПОЛИМОРФИЗМ Означает, что схожие объекты способны по-разному отвечать
на одно и то же сообщение. Например, у вас может быть система с множеством
фигур. Однако круг, квадрат и звезда рисуются по-разному. Используя полиморфизм,
вы можете отправить одно и то же сообщение (например, Draw ) объектам, на
каждый из которых возлагается обязанность по рисованию соответствующей
ему фигуры.

Этот подход направлен на обеспечение стандартизации определенного интер-
фейса среди классов, а также приложений. Представьте себе приложение из офис-
ного пакета, которое позволяет обрабатывать текст, и приложение для работы
с электронными таблицами. Предположим, что они оба включают класс с именем
Office , который содержит интерфейс с именем print() . Этот print() необходим всем
классам, являющимся частью офисного пакета. Любопытно, но несмотря на то, что
текстовый процессор и табличная программа вызывают интерфейс print() , они
делают разные вещи: один выводит текстовый документ, а другая — документ
с электронными таблицами.

ПОЛИМОРФИЗМ – расширение принципа наследования в ООП, реализуемое в JavaScript 
с помощью оператора prototype. Полиморфизм – это когда подкласс класса может 
вызвать ту же самую обобщенную унаследованную функцию в своем собственном контексте.

ПОЛИМОРФИЗМ Означает, что схожие объекты способны по-разному отвечать на одно и 
то же сообщение. Например, у вас может быть система с множеством фигур. Однако 
круг, квадрат и звезда рисуются по-разному. Используя полиморфизм, вы можете 
отправить одно и то же сообщение (например, Draw ) объектам, на каждый из 
которых возлагается обязанность по рисованию соответствующей ему фигуры.

#### ПОЛИМОРФИЗМ ПОДТИПОВ.
Полиморфизм подтипов заключается в том, что вызывающий код использует объект, 
опираясь только на его интерфейс (контракт), не зная при этом фактического типа. 
Такой подход позволяет подтипам реализовывать свое поведение и т.о. изменять 
поведение программы без перекомпиляции кода-клиента.
Например, это дает возможность при статической типизации указывать тип родительского 
класса для единообразной работы с массивом, стостоящим из дочерних (классов) типов. 



****************************************************************************
### **Множественное наследование, проблема ромбовидного наследования. Наследование через интерфейсы, делегирование.**
*
В большинстве объектно-ориентированных языков программирования (напри-
мер, Java, .NET и Objective C) у класса может иметься только один родительский,
но много дочерних классов. А в некоторых языках программирования, например
C++, у одного класса может быть несколько родительских классов. В первом случае
наследование называется простым, а во втором — множественным.

#### РОМБОВИДНОЕ НАСЛЕДОВАНИЕ (англ. diamond inheritance) 
— ситуация когда два класса B и C наследуют от A, а 
класс D наследует от обоих классов B и C. При этой схеме наследования может возникнуть неоднозначность: 
если метод класса D вызывает метод, определенный в классе A (и этот метод не был переопределен в классе D), 
а классы B и C по-своему переопределили этот метод, то от какого класса его наследовать: B или C?

C++ по умолчанию не создает ромбовидного наследования: компилятор обрабатывает каждый путь наследования отдельно, в результате чего объект D будет на самом деле содержать два разных подобъекта A, и при использовании членов A потребуется указать путь наследования (B::A или C::A). 
Чтобы сгенерировать ромбовидную структуру наследования, необходимо воспользоваться виртуальным наследованием класса A на нескольких путях наследования: если оба наследования от A к B и от A к C помечаются спецификатором virtual (например, class B : virtual public A), 
C++ специальным образом проследит за созданием только одного подобъекта A, и использование членов A будет работать корректно. Если виртуальное и невиртуальное наследования смешиваются, то получается один виртуальный подобъект A и по одному невиртуальному подобъекту A для каждого пути невиртуального наследования к A. При виртуальном вызове метода виртуального базового класса используется так называемое правило доминирования: компилятор запрещает виртуальный вызов метода, который был перегружен на нескольких путях наследования.


#### АБСТРАКТНЫЙ КЛАСС — это класс, у которого не реализован один или больше методов (абстрактные методы). 

#### ИНТЕРФЕЙС — это группа взаимосвязанных свойств и методов, которые описывают объект, но не обеспечивают реализацию или инициализацию этих свойств и методов в объектах.
Это описание полей.
ИНТЕРФЕЙС похож на абстрактный класс, у которого ни один метод не реализован, все они публичные и нет атрибутов класса.

Интерфейс описывает только интерфейс (sic!) - публичные методы без реализации.
Интерфейс содержит лишь декларации операций.

Интерфейсы по сути являются абстрактными базовыми классами, все методы которых также абстрактны, и где отсутствуют поля. 

Абстрактный базовый класс описывает некоторое семейство типов, но помимо декларации операций может содержать реализации по умолчанию (виртуальные методы) и фиксированные операции (невиртуальные методы).

Абстрактный класс нужен, когда нужно семейство классов, у которых есть много общего. Конечно, можно применить и интерфейс, но тогда нужно будет писать много идентичного кода (переопределять все методы, а не наследовать уже готовые).

В некоторых языках (С++) специального ключевого слова для обозначения интерфейсов нет.
Можно считать, что любой интерфейс — это уже абстрактный класс, но не наоборот.

Конкретный класс описывает некоторое семейство типов, которое готово для использования клиентами. Такой класс не может содержать декларации операций и все его операции должны быть либо фиксированными (невиртуальные методы) или содержать реализацию по умолчанию (виртуальные методы). 

Интерфейс описывает только интерфейс - публичные методы без реализации.
Интерфейс содержит лишь декларации операций.

ИНТЕРФЕЙС определяет конкретное поведение, а не реализацию. 
Реализуя интерфейс Nameable, вы подразумеваете, что обеспечите соответствующее 
поведение с помощью реализации методов getName() и setName(). Вам решать, как 
именно вы это сделаете.
Все, что вам потребуется, — обеспечить данные методы.

Простое правило при определении контракта заключается в обеспечении нереали-
зованного метода с помощью либо абстрактного класса, либо интерфейса. Таким
образом, когда подкласс проектируется с намерением реализовать контракт, он
должен обеспечивать реализацию нереализованных методов в родительском клас-
се или интерфейсе.
public interface Nameable {
  public String getName();
  public void setName(String aName);
}
Новые классы Planet , Car и Dog должны выглядеть так:
public class Planet implements Nameable {
  String planetName;
  public String getName() {return planetName;}
  public void setName(String myName) { planetName = myName;}
}
public class Car implements Nameable {
  String carName;
  public String getName() {return carName;}
  public void setName(String myName) { carName = myName;}
}

Обобщить в двух словах — если необходимо создать экземпляр объекта, при этом получив преимущества проверки типов таких сущностей как аргументы, возвращаемые типы или generics — имеет смысл использовать класс.

Если вы не создаете экземпляры — в нашем распоряжении есть интерфейсы и их преимущество заключается в том, что при этом не создается какой-либо дополнительного кода, но предоставляется возможность “виртуальной” проверки типизации кода.

ДЕЛЕГИРОВАНИЕ - это Агрегация - включение объекты как части нового объекта.


****************************************************************************
### Связность(cohesion)++, связанность(зацепление, coupling)--. 
### Как повысить связность, как понизить связанность? Декомпозиция.
*

Связность(cohesion) и связанность(coupling)
http://nuts-dotnet.blogspot.com/2010/10/cohesion-coupling.html

Связность, или прочность (англ. cohesion, module strength), — мера силы взаимосвязанности элементов внутри модуля; способ и степень, в которой задачи, выполняемые некоторым 
программным модулем, связаны друг с другом.

Сильная связность означает сохранять подобные и связанные элементы вместе.

Объяснение связности на примере класса (как частного случая модуля): «связность характеризует то, насколько 
хорошо все методы класса или все фрагменты метода соответствуют главной цели, — иначе говоря, насколько 
сфокусирован класс».

Важно помнить при разработке приложения, что нужно писать модули со слабой увязкой. 
Старайтесь избегать ситуации, когда ваш класс выполняет более одного специфичного действия. 
Название класса должно точно формулировать его специализацию. Проводя рефакторинг, по возможности, 
выносите нехарактерные для вашего класса операции в отдельных класс. 

Связность обычно противопоставляется зацеплению. Слабое зацепление является признаком хорошо структурированной 
и хорошо спроектированной системы, и, когда она комбинируется с сильной связностью, соответствует общим 
показателям хорошей читаемости и сопровождаемости.

#### Связанность, Зацепление, сцепление, сопряжение (англ. coupling) — способ и степень взаимозависимости между программными 
модулями; сила взаимосвязей между модулями; мера того, насколько взаимозависимы разные подпрограммы или 
модули.

#### Зацепление - это степень зависимости классов друг от друга
Зацепление лучше понижать
  - прямая, видимая и гибкая связь с другими классами предпочтительна
  - модуль должно быть легко использовать с другими модулями
  - модули должны слабо зависеть друг от друга или быть независимыми

Слабое зацепление:
  - Easily replace old HDD
  - Easily place this HDD to another motherboard

Сильное зацепление:
  - Where is the video adapter?
  - Can you change the video controller?
Комбинация слабой связности и сильного зацепления легко порождает код-лапшу.

Сильное зацепление рассматривается как серьёзный недостаток, поскольку затрудняет понимание логики модулей, их модификацию, автономное тестирование, а также переиспользование по отдельности. Слабое зацепление, напротив, является признаком хорошо структурированной и хорошо спроектированной системы, и, когда она комбинируется с сильной связностью, соответствует общим показателям хорошей читаемости и сопровождаемости.

Классы, которые сильно зависят друг от друга, считаются тесно СВЯЗАННЫМИ. Таким образом, 
если изменение, внесенное в один класс, приводит к изменению в другом классе, то эти два класса будут считаться тесно связанными. Классы, лишенные таких зависимостей, обладают очень низкой степенью связанности.
Если классы изначально правильно спроектированы, то любые изменения в системе должны вноситься только в реализацию объекта. Изменений открытого интерфейса следует избегать 
любой ценой. Любые изменения открытого интерфейса приведут к волновым эффектам во всех системах, задействующих этот интерфейс.
Например, если внести изменение в метод getName() класса Cabbie , то все места во всех системах, где используется этот интерфейс, потребуется изменить и перекомпилировать. Обнаружение всех соответствующих вызовов методов — это грандиозная задача, а вероятность упустить один из них довольно высока.
Для обеспечения высокого уровня сопровождаемости делайте так, чтобы степень связанности 
ваших классов была как можно ниже.

#### ДЕКОМПОЗИЦИЯ.
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment

Декомпозиция (destructuring) позволяет извлечь из объекта отдельные значения в переменные:
```
let user = {
    name: "Tom",
    age: 24,
    phone: "+367438787",
    email: "tom@gmail.com"
};
let {name, email} = user;
console.log(name);      // Tom
console.log(email);     // tom@gmail.com
```
Для декомпозиции объекта переменные помещаются в фигурные скобки и им присваивается объект. Сопоставление между свойствами объекта и переменными идет по имени.

Мы можем указать, что мы хотим получить значения свойств объекта в переменные с другим именем:
```
let user = {
    name: "Tom",
    age: 24,
    phone: "+367438787",
    email: "tom@gmail.com"
};
let {name: userName, email: mailAddress} = user;
console.log(userName);      // Tom
console.log(mailAddress);       // tom@gmail.com
```
В данном случае свойство name сопоставляется с переменной userName, а поле email - с переменной mailAddress.

мы можем пропустить ряд элементов массива, оставив вместо имен переменных пропуски:
```
let users = ["Tom", "Sam", "Bob", "Ann", "Alice", "Kate"];
let [first,,,,fifth] = users;
console.log(first);     // Tom
console.log(fifth);     // Alice
```
Если в функцию в качестве параметра передается массив или объект, то его также можно подобным образом декомпозировать:
```
function display({name:userName, age:userAge}){
    console.log(userName, userAge);
}
function sum([a, b, c]){
    var result = a + b + c;
    console.log(result);
}
let user = {name:"Alice", age:33, email: "alice@gmail.com"};
let numbers = [3, 5, 7, 8];
display(user);  // Alice 33
sum(numbers);   // 15
```

**Обмен значений переменных**
После выполнения фрагмента кода, значение b будет 1, a будет 3. Без деструктурирующего присваивания, для обмена значений требуется дополнительная временная переменная (или что-то наподобие XOR-обмена).
```
var a = 1;
var b = 3;
[a, b] = [b, a];
```
Вы также можете проигнорировать не нужные значения:
```
function f() {
  return [1, 2, 3];
}
var [a, , b] = f();
```

**Получение значений из результата регулярного выражения**
Когда метод exec() регулярного выражения находит совпадение, он возвращает массив, содержащий первый совпадающий фрагмент строки и далее группы, определённые в регулярном выражении. Деструктурирующее присваивание упрощает получение данных из этих групп, игнорируя первый фрагмент:
```
var url = "https://developer.mozilla.org/en-US/Web/JavaScript";
var parsedURL = /^(\w+)\:\/\/([^\/]+)\/(.*)$/.exec(url);
var [, protocol, fullhost, fullpath] = parsedURL;
console.log(protocol); // выведет "https:"
```
**Вложенный объект и разбор массива**
```
var metadata = {
    title: "Scratchpad",
    translations: [
       {
        locale: "de",
        localization_tags: [ ],
        last_edit: "2014-04-14T08:43:37",
        url: "/de/docs/Tools/Scratchpad",
        title: "JavaScript-Umgebung"
       }
    ],
    url: "/en-US/docs/Tools/Scratchpad"
};
var { title: englishTitle, translations: [{ title: localeTitle }] } = metadata;
console.log(englishTitle); // "Scratchpad"
console.log(localeTitle);  // "JavaScript-Umgebung"
```
**Деструктурирование во время обхода**
```
var people = [
  {
    name: "Mike Smith",
    family: {
      mother: "Jane Smith",
      father: "Harry Smith",
      sister: "Samantha Smith"
    },
    age: 35
  },
  {
    name: "Tom Jones",
    family: {
      mother: "Norah Jones",
      father: "Richard Jones",
      brother: "Howard Jones"
    },
    age: 25
  }
];
for (var {name: n, family: { father: f } } of people) {
  console.log("Name: " + n + ", Father: " + f);
}
// "Name: Mike Smith, Father: Harry Smith"
// "Name: Tom Jones, Father: Richard Jones"
```
**Получение полей объекта-параметра функции**
```
function userId({id}) {
  return id;
}
function whois({displayName, fullName: {firstName: name}}){
  console.log(displayName + " is " + name);
}
var user = { 
  id: 42, 
  displayName: "jdoe",
  fullName: { 
      firstName: "John",
      lastName: "Doe"
  }
};
console.log("userId: " + userId(user)); // "userId: 42"
whois(user); // "jdoe is John"
```

**Деструктурирование вычисляемых имён свойств**
Вычисляемые имена свойств, например, литералы объектов, могут использоваться при деструктурирующем присваивании:
```
let key = "z";
let { [key]: foo } = { z: "bar" };
console.log(foo); // "bar"
```


****************************************************************************
### UML диаграмма классов.


#### UML-ДИАГРАММЫ КЛАССОВ (Unified Modeling Language - унифицированныйо язык моделиро-
вания)
Это были первые диаграммы классов, которые мы рассмотрели. Как видите, они весьма
просты и лишены части конструкций (таких, например, как конструкторы), которые
должен содержать надлежащий класс. 
Каждая диаграмма определяется тремя отдельными секциями: именем как та-
ковым, данными (атрибутами) и поведениями (методами).

Employee
-socialSecurityNumber: string
-gender: boolean

+gerSocialSecurityNumber:string
+getGender:boolean
+setGender:void

В UML-диаграмме
знак плюса ( + ) обозначает public , а знак минуса ( – ) указывает на private
знак решетки ( # ) обозначает Protected

Общий вид
------------
Имя класса
------------
-атрибут1:int
+атрибут2:string
------------
+конструктор:
+Метод1:void
-Метод2:int
-Метод3:string
------------

|   Общий вид      | 
|:----------------:| 
|   Имя класса     | 
|:----------------:| 
| -атрибут1:int    | 
| +атрибут2:string | 
|:----------------:| 
| +конструктор:    | 
| +Метод1:void     | 
| -Метод2:int      | 
| +Метод3:string   | 


#### Как повысить связность, как понизить связанность?
Применить 4-й принцип из SOLID - Принцип разделения интерфейса (Interface Segregation Principle или ISP): 
много специализированных интерфейсов лучше, чем один универсальный. Другими словами, вам не придется 
реализовать методы, которые вы не используете. Осуществление ISP дает слабую связанность и сильную связность.

