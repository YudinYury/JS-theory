# Backend developer checklist (все по ООП, подчернутые в приоритете)

****************************************************************************
## Stage 1, part 3 

## Web
Вопросы в этом разделе:
  * get, post, option; body, query; http status
  * REST - принципы наименование методов, принцип stateless

## GIT
Вопросы в этом разделе:
  * Как добавить файлы в коммит? Почему нельзя добавлять файлы по звезде или точке?
  * Пуш. Что такое фастфовард? Чем опасен пуш с форсом?
  * Ветвление. Как создать и удалить ветку, локально и в origin`е. Как привязать локальную ветку "a1" к удаленной ветке "b2", и пушить в нее? 
  * Что такое мердж? Как его откатить? 
  * Как перименовать коммит? Как удалить последний? Как удалить коммит из середины и запушить его? В каких случаях так можно делать, а в каких нет?


****************************************************************************
### **Web**


****************************************************************************
#### get, post, option; body, query; http status
*
**HTTP**
Этот протокол описывает взаимодействие между двумя компьютерами (клиентом и сервером), построенное на базе сообщений, называемых запрос (Request) и ответ (Response). Каждое сообщение состоит из трех частей: стартовая строка, заголовки и тело. При этом обязательной является только стартовая строка. 
```
METHOD URI HTTP/VERSION,
```
где METHOD — это как раз метод HTTP-запроса, URI — идентификатор ресурса, VERSION — версия протокола (на данный момент актуальна версия 1.1).
Запрос:
```
GET /index.php HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0 (X11; U; Linux i686; ru; rv:1.9b5) Gecko/2008050509 Firefox/3.0b5
Accept: text/html
Connection: close
```
Первая строка — это строка запроса, остальные — заголовки; тело сообщения отсутствует

Ответ:
```
HTTP/1.0 200 OK
Server: nginx/0.6.31
Content-Language: ru
Content-Type: text/html; charset=utf-8
Content-Length: 1234
Connection: close
```
... САМА HTML-СТРАНИЦА ...

Для разграничения действий с ресурсами на уровне HTTP-методов и были придуманы следующие варианты:
GET — получение ресурса
POST — создание ресурса
PUT — обновление ресурса
DELETE — удаление ресурса
Cпецификация HTTP НЕ ОБЯЗЫВАЕТ сервер понимать все методы (которых на самом деле гораздо больше, чем 4) — обязателен только GET, а также не указывает серверу, что он должен делать при получении запроса с тем или иным методом. А это значит, что сервер в ответ на запрос DELETE /index.php HTTP/1.1 не обязан удалять страницу index.php на сервере, так же как на запрос GET /index.php HTTP/1.1 не обязан возвращать вам страницу index.php, он может ее удалять.

Метод HTTP запроса **OPTIONS** используется для описания  параметров соединения с целевым ресурсом. Клиент может указать особый URL для обработки OPTIONS метода, или * (зведочку) чтобы указать весь сервер целиком.

Запрос содержит тело (body)	Нет
Успешный ответ содержит тело	Да
Safe	Да
Idempotent	Да
Cacheable	Нет
Разрешено использовать для HTML форм	Нет
Link to sectionСинаксис
OPTIONS /index.html HTTP/1.1
OPTIONS * HTTP/1.1


****************************************************************************
#### REST - принципы наименование методов, принцип stateless
*
https://habr.com/post/50147/
https://habr.com/post/38730/

**REST (REpresentational State Transfer)** — это термин был введен в 2000-м году Роем Филдингом (Roy Fielding) — одним из разработчиков протокола HTTP — в качестве названия группы принципов построения веб-приложений. Вообще REST охватывает более широкую область, нежели HTTP — его можно применять и в других сетях с другими протоколами. REST описывает принципы взаимодействия клиента и сервера, основанные на понятиях «ресурса» и «глагола» (можно понимать их как подлежащее и сказуемое). 
В случае HTTP ресурс определяется своим URI, а глагол — это HTTP-метод.

Системы, поддерживающие REST, называются RESTful-системами.

REST предлагает отказаться от использования одинаковых URI для разных ресурсов (то есть адреса двух разных статей вроде /index.php?article_id=10 и /index.php?article_id=20 — это не REST-way) и использовать разные HTTP-методы для разных действий. То есть веб-приложение, написанное с использованием REST подхода будет удалять ресурс при обращении к нему с HTTP-методом DELETE (разумеется, это не значит, что надо давать возможность удалить всё и вся, но любой запрос на удаление в приложении должен использовать HTTP-метод DELETE).

REST дает программистам возможность писать стандартизованные и чуть более красивые веб-приложения, чем раньше. Используя REST, URI для добавления нового юзера будет не /user.php?action=create (метод GET/POST), а просто /user.php (метод строго POST).

В итоге, совместив имеющуюся спецификацию HTTP и REST-подход наконец-то обретают смысл различные HTTP-методы. 
GET — возвращает ресурс, POST — создает новый, PUT — обновляет существующий, DELETE — удаляет.

Каждая единица информации однозначно определяется URL – это значит, что URL по сути является первичным ключом для единицы данных. Т.е. например третья книга с книжной полки будет иметь вид /book/3, а 35 страница в этой книге — /book/3/page/35. Отсюда и получается строго заданный формат. Причем совершенно не имеет значения, в каком формате находятся данные по адресу /book/3/page/35 – это может быть и HTML, и отсканированная копия в виде jpeg-файла, и документ Microsoft Word.

Как происходит управление информацией сервиса – это целиком и полностью основывается на протоколе передачи данных. Наиболее распространенный протокол конечно же HTTP. Так вот, для HTTP действие над данными задается с помощью методов:
  * GET (получить), 
  * PUT (добавить, заменить), 
  * POST (добавить, изменить, удалить), 
  * DELETE (удалить). 

Таким образом, действия CRUD (Create-Read-Updtae-Delete) могут выполняться как со всеми 4-мя методами, так и только с помощью GET и POST.

Вот как это будет выглядеть на примере:

GET /book/ — получить список всех книг 
GET /book/3/ — получить книгу номер 3 
PUT /book/ — добавить книгу (данные в теле запроса) 
POST /book/3 – изменить книгу (данные в теле запроса) 
DELETE /book/3 – удалить книгу 

ВАЖНОЕ ДОПОЛНЕНИЕ: Существуют так называемые REST-Patterns, которые различаются связыванием HTTP-методов с тем, что они делают. В частности, разные паттерны по-разному рассматривают POST и PUT. Однако, PUT предназначен для создания, реплейса или апдейта, для POST это не определено (The POST operation is very generic and no specific meaning can be attached to it). Поэтому мой пример будет правильным и в таком виде, и в виде если поменять местами POST и PUT.

Вообще, POST может использоваться одновременно для всех действий изменения: 
POST /book/ – добавить книгу (данные в теле запроса)
POST /book/3 – изменить книгу (данные в теле запроса)
POST /book/3 – удалить книгу (тело запроса пустое)

**Использование REST для построения Web-сервисов.**

**web-сервис** – это приложение работающее в World Wide Web и доступ к которому предоставляется по HTTP-протоколу, а обмен информации идет с помощью формата XML. Следовательно, формат данных передаваемых в теле запроса будет всегда XML. 

Для каждой единицы информации (info) определяется 5 действий. А именно:

GET /info/ (Index) – получает список всех объектов. Как правило, это упрощенный список, т.е. содержащий только поля идентификатора и названия объекта, без остальных данных.

GET /info/{id} (View) – получает полную информацию о объекте.

PUT /info/ или POST /info/ (Create) – создает новый объект. Данные передаются в теле запроса без применения кодирования, даже urlencode. 

POST /info/{id} или PUT /info/{id} (Edit) – изменяет данные с идентификатором {id}, возможно заменяет их. Данные так же передаются в теле запроса, но в отличие от PUT здесь есть некоторый нюанс. Дело в том, что POST-запрос подразумевает наличие urldecoded-post-data. Т.е. если не применять кодирования – это нарушение стандарта. Тут кто как хочет – некоторые не обращают внимания на стандарт, некоторые используют какую-нибудь post-переменную.
```
DELETE /info/{id} (Delete) – удаляет данные с идентификатором {id}.
```
Еще раз отмечу, что в нашем примере /info/ — может и базироваться на какой-то другой информации, что может быть (и должно) быть отражено в URL:

/data/4/otherdata/6/info/3/ … и тому подобное.

Какие можно сделать из этого выводы:

Как видно, в архитектура REST очень проста в плане использования. По виду пришедшего запроса сразу можно определить, что он делает, не разбираясь в форматах (в отличие от SOAP, XML-RPC). Данные передаются без применения дополнительных слоев, поэтому REST считается менее ресурсоемким, поскольку не надо парсить запрос чтоб понять что он должен сделать и не надо переводить данные из одного формата в другой. 

Практическое применение.

Самое главное достоинство сервисов в том, что с ними работать может какая угодно система, будь то сайт, flash, программа и др. так как методы парсинга XML и выполнения запросов HTTP присутствуют почти везде. 

**Принцип stateless**

Термины stateful и stateless описывают, нужно ли компьютеру или программе устанавливать и запоминать одно или несколько предшествующих событий в последовательности взаимодействия с пользователем, другим компьютером или программой, устройством или внешним элементом. В данном случае stateless означает, что все методы объекта работают вне какого-либо контекста или локального состояния объекта. Клиентам и серверам нет необходимости хранить данные о каждом состоянии друг друга. Если клиент не взаимодействует с сервером, последнему нет нужды знать о состоянии первого. При этом сервер также не хранит информацию о предыдущих запросах. Каждый запрос рассматривается вне контекста, как отдельный.


****************************************************************************
### **GIT**
https://git-scm.com/book/ru/v2

****************************************************************************
#### Как добавить файлы в коммит? Почему нельзя добавлять файлы по звезде или точке?
*
https://eax.me/git-commands/ 

Добавить файл в репозиторий:
```
git add text.txt
```
Удалить файл:
```
git rm text.txt
```
Текущее состояние репозитория (изменения, неразрешенные конфликты и тп):
```
git status
```

****************************************************************************
#### Пуш. Что такое фастфовард? Чем опасен пуш с форсом?
*

**PUSH**
```
git push origin
```
Замержить все ветки локального репозитория на удаленный репозиторий (аналогично вместо origin можно указать и remotename).


**fast-forward**

http://gearmobile.github.io/git/fast-forward-git/


https://urvanov.ru/2017/09/19/%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C-git-push-force-%D0%B8-%D0%BF%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%BE%D1%81%D1%82%D1%8C-git-push-force-with-lease/

Осторожно: в общем случае команда push --force опасна, так как переписывает состояние ветки на удаленном репозитории и может привести к потерям.

Например, если кто-то добавит свой коммит в ветку master, а потом вы переименуете свою ветку и сделаете push --force, то чужой коммит будет потерян.

Было:
```
локальный: A---B2 (master) 
            \
             B

удаленный: A---B---С (origin/master)
```
Стало: чужой коммит C потерян
```
удаленный: A---B2 (origin/master)
            \
             B---С # недоступен
```


****************************************************************************
#### Ветвление. Как создать и удалить ветку, локально и в origin`е. Как привязать локальную ветку "a1" к удаленной ветке "b2", и пушить в нее?
*
```
git branch testing  # создать ветку testing
git checkout testing  # переключиться (переместить указатель HEAD) на ветку testing
```
надо изменить url удалённого репозитория (remote в терминологии git):
```
$ git remote set-url origin url-нового-репозитория
```
здесь подразумевается, что умолчальное имя удалённого репозитория — origin — вы не меняли.
```
git branch --set-upstream-to my_branch origin/my_branch
```
Или из текущей ветки, из которой хочу коммитить/пушить я делаю один раз 
```
git push  --set-upstream-to origin/target_branch 
```

****************************************************************************
#### Что такое мердж? Как его откатить?
*
https://git-scm.com/book/ru/v2/%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-Git-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-%D0%B2%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8-%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D1%8F

Предположим, вы решили, что работа по проблеме #53 закончена, и ее можно влить в ветку master. Для этого нужно выполнить слияние ветки iss53 точно так же, как вы делали это с веткой hotfix ранее. Все что нужно сделать — переключиться на ветку, в которую вы хотите включить изменения, и выполнить команду git merge:
```
$ git checkout master
Switched to branch 'master'
$ git merge iss53
Merge made by the 'recursive' strategy.
index.html |    1 +
1 file changed, 1 insertion(+)
```

**отменить merge**

Есть репозиторий, с двумя бранчами – master и rdsmanager_NG-1.

Изменения в rdsmanager_NG-1 были смерджены в master.

Необходимо отменить это объединение.

Находим “лишний” мердж:
```
D:RDSrdsmanager>git log
commit d22654c64574d1f01ef49f12bf0688c7c9cc3c1d
Author: Your Name <you@example.com>
Date:   Wed Sep 2 00:42:05 2015 +0300
    11
commit 7bad6f70aa0d10717b55a141e9d85b4305ade67c
Author: User Name <user@domain.com>
Date:   Tue Sep 1 17:52:05 2015 +0300
    NG-6727 RDSmanager user fix
```
В данном случае – коммит с ID d22654c64574d1f01ef49f12bf0688c7c9cc3c1d – не нужен.

Выполняем откат до предыдущего коммита:
```
D:RDSrdsmanager>git reset --hard 7bad6f70aa0d10717b55a141e9d85b4305ade67c
HEAD is now at 7bad6f7 NG-6727 RDSmanager user fix
```
Сохраняем изменения в самом репозитории:
```
D:RDSrdsmanager>git push --force origin master
Total 0 (delta 0), reused 0 (delta 0)
To git@bitbucket.domain/rdsmanager.git
 + d22654c...7bad6f7 master -> master (forced update)
```


Обозначим начальную ситуацию на следующей схеме:
```
               (i) (wt)
A - B - C - D - ? - ?
            ↑
          master
          (HEAD)
```

**git stash**
Эта команда отменяет все индексированные и неиндексированные изменения в рабочей области, сохраняя их в карман (stash).
```
git stash save
```
Конечное состояние:
```
           (wt)
           (i)           
A - B - C - D             ?
            ↑             ↑
          master      stash{0}
          (HEAD)
```
Восстановление несохраненных изменений: легко и просто.
```
git stash apply  #  git stash pop
```
Если stash совсем не нужен, его можно удалить.
```
# удалить последнюю запись кармана
git stash drop
```


****************************************************************************
#### Как перименовать коммит? Как удалить последний? 
*
Предположим, что есть вот такая история коммитов. На локальном и удаленном сервере одна и та же история:
```
локальный: A---B (master)

удаленный: A---B (origin/master)
```
Для переименования коммита действительно нужно выполнить команду.
```
git commit --amend -m 'Новое сообщение'
```
Стало после --amend:
```
локальный: A---B2 (master) # совершенно другой коммит, хоть и с тем же содержимым)
            \
             B # не удален, но больше не принадлежит ветке master.
               # можно восстановить через git reflog

удаленный: A---B (origin/master)
```
После этого придётся явным образом переписать ветку master на удаленном репозитории (на GitHub). Поскольку история коммитов разошлась, GitHub не примет изменения просто так, нужно добавить ключ --force:
```
git push --force origin <имя ветки на удаленном репозитории>
```
Было:
```
локальный: A---B2 (master) 
            \
             B

удаленный: A---B (origin/master)
```
Стало после push --force:
```
удаленный: A---B2 (origin/master)
            \
             B # вообще недоступен, потому что у вас нет доступа к файловой системе гитхаба
               # уберется сборщиком мусора на сервере
```


**Отмена последнего коммита в git**
Допустим, вы сделали commit в git, но поняли, что он недостаточно хорош. В таком случае можно продолжить правки, а при следующем коммите набрать
```
    git commit -a --amend
```
Ключ --amend (улучшить, в переводе с английского) позволяет добавить к последнему коммиту новые изменения.

Если вы сделали commit в git, но поняли, что он достаточно плох, то можно сделать и так:
```
    git reset --soft HEAD^
```
Эта команда отменит последний коммит (но не изменения, которые вы внесли, они сохранятся).

Если последний коммит отвратителен, то можно вообще его удалить:
```
    git reset --hard HEAD^
```
Все это работает, если вы не опубликовали свои изменения. В случае, если вы их опубликовали, то не остается ничего другого, как сделать коммит, который отменяет какой-то коммит:
```
    git revert commit-sha1
```
Ну, а потом опубликовать поскорее его командой git push.



****************************************************************************
#### Как удалить коммит из середины и запушить его? В каких случаях так можно делать, а в каких нет?
*

