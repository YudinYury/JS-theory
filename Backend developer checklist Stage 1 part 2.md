# Backend developer checklist (все по ООП, подчернутые в приоритете)

****************************************************************************
## Stage 1, part 2 
## ООП
Вопросы в этом разделе:
  * Множественное наследование, проблема ромбовидного наследования. Наследование через интерфейсы, делегирование.
  * Связность, связанность. Как повысить связность, как понизить связанность? Декомпозиция.
  * UML диаграмма классов.
  * Шаблоны (понимание, обоснование применения): Издатель-подписчик (Publish–subscribe),  Одиночка, Фабричный метод, Абстрактная фабрика.
  * MVC - Отношения между моделью, вьюхой и контроллером.
  * СОЛИД, первые четыре принципа (поверхностное представление).

****************************************************************************

### **Объект** 
— это именованная сущность, одновременно содержащая данные(свойства) и поведения(методы).
Слово «одновременно» в данном случае определяет ключевую разницу между ООП и 
другими методологиями программирования. Например, при процедурном программировании 
код размещается в полностью отдельных функциях или процедурах.

**Класс** - это шаблон, предназначенный для создания объектов.
Класс - это именованная сущность из предметной области, возможно, имеющая 
предка (суперкласс), определенная как набор полей и методов.

В JavaScript классы можно организовать по-разному. Говорят, что класс User написан 
в «функциональном» стиле. Далее мы также увидим «прототипный» стиль.


****************************************************************************
### **Множественное наследование, проблема ромбовидного наследования. Наследование через интерфейсы, делегирование.**
*
В большинстве объектно-ориентированных языков программирования (напри-
мер, Java, .NET и Objective C) у класса может иметься только один родительский,
но много дочерних классов. А в некоторых языках программирования, например
C++, у одного класса может быть несколько родительских классов. В первом случае
наследование называется простым, а во втором — множественным.

#### РОМБОВИДНОЕ НАСЛЕДОВАНИЕ (англ. diamond inheritance) 
— ситуация когда два класса B и C наследуют от A, а 
класс D наследует от обоих классов B и C. При этой схеме наследования может возникнуть неоднозначность: 
если метод класса D вызывает метод, определенный в классе A (и этот метод не был переопределен в классе D), 
а классы B и C по-своему переопределили этот метод, то от какого класса его наследовать: B или C?

C++ по умолчанию не создает ромбовидного наследования: компилятор обрабатывает каждый путь наследования отдельно, в результате чего объект D будет на самом деле содержать два разных подобъекта A, и при использовании членов A потребуется указать путь наследования (B::A или C::A). 
Чтобы сгенерировать ромбовидную структуру наследования, необходимо воспользоваться виртуальным наследованием класса A на нескольких путях наследования: если оба наследования от A к B и от A к C помечаются спецификатором virtual (например, class B : virtual public A), 
C++ специальным образом проследит за созданием только одного подобъекта A, и использование членов A будет работать корректно. Если виртуальное и невиртуальное наследования смешиваются, то получается один виртуальный подобъект A и по одному невиртуальному подобъекту A для каждого пути невиртуального наследования к A. При виртуальном вызове метода виртуального базового класса используется так называемое правило доминирования: компилятор запрещает виртуальный вызов метода, который был перегружен на нескольких путях наследования.


#### АБСТРАКТНЫЙ КЛАСС — это класс, у которого не реализован один или больше методов (абстрактные методы). 

#### ИНТЕРФЕЙС — это абстрактный класс, у которого ни один метод не реализован, все они публичные и нет атрибутов класса.

Интерфейс описывает только интерфейс (sic!) - публичные методы без реализации.
Интерфейс содержит лишь декларации операций.

Абстрактный базовый класс описывает некоторое семейство типов, но помимо декларации операций может содержать реализации по умолчанию (виртуальные методы) и фиксированные операции (невиртуальные методы).

Абстрактный класс нужен, когда нужно семейство классов, у которых есть много общего. Конечно, можно применить и интерфейс, но тогда нужно будет писать много идентичного кода (переопределять все методы, а не наследовать уже готовые).

В некоторых языках (С++) специального ключевого слова для обозначения интерфейсов нет.
Можно считать, что любой интерфейс — это уже абстрактный класс, но не наоборот.

Конкретный класс описывает некоторое семейство типов, которое готово для использования клиентами. Такой класс не может содержать декларации операций и все его операции должны быть либо фиксированными (невиртуальные методы) или содержать реализацию по умолчанию (виртуальные методы). 

#### ИНТЕРФЕЙС — это абстрактный класс, у которого ни один метод не реализован, все они публичные и нет атрибутов класса.

Интерфейс описывает только интерфейс - публичные методы без реализации.
Интерфейс содержит лишь декларации операций.

ИНТЕРФЕЙС определяет конкретное поведение, а не реализацию. 
Реализуя интерфейс Nameable, вы подразумеваете, что обеспечите соответствующее 
поведение с помощью реализации методов getName() и setName(). Вам решать, как 
именно вы это сделаете.
Все, что вам потребуется, — обеспечить данные методы.

Простое правило при определении контракта заключается в обеспечении нереали-
зованного метода с помощью либо абстрактного класса, либо интерфейса. Таким
образом, когда подкласс проектируется с намерением реализовать контракт, он
должен обеспечивать реализацию нереализованных методов в родительском клас-
се или интерфейсе.
public interface Nameable {
  public String getName();
  public void setName(String aName);
}
Новые классы Planet , Car и Dog должны выглядеть так:
public class Planet implements Nameable {
  String planetName;
  public String getName() {return planetName;}
  public void setName(String myName) { planetName = myName;}
}
public class Car implements Nameable {
  String carName;
  public String getName() {return carName;}
  public void setName(String myName) { carName = myName;}
}

Интерфейсы по сути являются абстрактными базовыми классами, все методы которых также абстрактны, и 
где отсутствуют поля. 

ДЕЛЕГИРОВАНИЕ - это Агрегация - включение объекты как части нового объекта.


****************************************************************************
### Связность(cohesion)++, связанность(зацепление, coupling)--. 
### Как повысить связность, как понизить связанность? Декомпозиция.
*

Связность(cohesion) и связанность(coupling)
http://nuts-dotnet.blogspot.com/2010/10/cohesion-coupling.html

Связность, или прочность (англ. cohesion, module strength), — мера силы взаимосвязанности элементов внутри модуля; способ и степень, в которой задачи, выполняемые некоторым 
программным модулем, связаны друг с другом.

Сильная связность означает сохранять подобные и связанные элементы вместе.

Объяснение связности на примере класса (как частного случая модуля): «связность характеризует то, насколько 
хорошо все методы класса или все фрагменты метода соответствуют главной цели, — иначе говоря, насколько 
сфокусирован класс».

Важно помнить при разработке приложения, что нужно писать модули со слабой увязкой. 
Старайтесь избегать ситуации, когда ваш класс выполняет более одного специфичного действия. 
Название класса должно точно формулировать его специализацию. Проводя рефакторинг, по возможности, 
выносите нехарактерные для вашего класса операции в отдельных класс. 

Связность обычно противопоставляется зацеплению. Слабое зацепление является признаком хорошо структурированной 
и хорошо спроектированной системы, и, когда она комбинируется с сильной связностью, соответствует общим 
показателям хорошей читаемости и сопровождаемости.

#### Связанность, Зацепление, сцепление, сопряжение (англ. coupling) — способ и степень взаимозависимости между программными 
модулями; сила взаимосвязей между модулями; мера того, насколько взаимозависимы разные подпрограммы или 
модули.

#### Зацепление - это степень зависимости классов друг от друга
Зацепление лучше понижать
  - прямая, видимая и гибкая связь с другими классами предпочтительна
  - модуль должно быть легко использовать с другими модулями
  - модули должны слабо зависеть друг от друга или быть независимыми

Слабое зацепление:
  - Easily replace old HDD
  - Easily place this HDD to another motherboard

Сильное зацепление:
  - Where is the video adapter?
  - Can you change the video controller?
Комбинация слабой связности и сильного зацепления легко порождает код-лапшу.

Сильное зацепление рассматривается как серьёзный недостаток, поскольку затрудняет понимание логики модулей, их модификацию, автономное тестирование, а также переиспользование по отдельности. Слабое зацепление, напротив, является признаком хорошо структурированной и хорошо спроектированной системы, и, когда она комбинируется с сильной связностью, соответствует общим показателям хорошей читаемости и сопровождаемости.

Классы, которые сильно зависят друг от друга, считаются тесно СВЯЗАННЫМИ. Таким образом, 
если изменение, внесенное в один класс, приводит к изменению в другом классе, то эти два класса будут считаться тесно связанными. Классы, лишенные таких зависимостей, обладают очень низкой степенью связанности.
Если классы изначально правильно спроектированы, то любые изменения в системе должны вноситься только в реализацию объекта. Изменений открытого интерфейса следует избегать 
любой ценой. Любые изменения открытого интерфейса приведут к волновым эффектам во всех системах, задействующих этот интерфейс.
Например, если внести изменение в метод getName() класса Cabbie , то все места во всех системах, где используется этот интерфейс, потребуется изменить и перекомпилировать. Обнаружение всех соответствующих вызовов методов — это грандиозная задача, а вероятность упустить один из них довольно высока.
Для обеспечения высокого уровня сопровождаемости делайте так, чтобы степень связанности 
ваших классов была как можно ниже.

****************************************************************************
### UML диаграмма классов.


#### UML-ДИАГРАММЫ КЛАССОВ (Unified Modeling Language - унифицированныйо язык моделиро-
вания)
Это были первые диаграммы классов, которые мы рассмотрели. Как видите, они весьма
просты и лишены части конструкций (таких, например, как конструкторы), которые
должен содержать надлежащий класс. 
Каждая диаграмма определяется тремя отдельными секциями: именем как та-
ковым, данными (атрибутами) и поведениями (методами).

Employee
-socialSecurityNumber: string
-gender: boolean

+gerSocialSecurityNumber:string
+getGender:boolean
+setGender:void

В UML-диаграмме
знак плюса ( + ) обозначает public , а знак минуса ( – ) указывает на private
знак решетки ( # ) обозначает Protected

Общий вид
------------
Имя класса
------------
-атрибут1:int
+атрибут2:string
------------
+конструктор:
+Метод1:void
-Метод2:int
-Метод3:string
------------

|   Общий вид      | 
|:----------------:| 
|   Имя класса     | 
|:----------------:| 
| -атрибут1:int    | 
| +атрибут2:string | 
|:----------------:| 
| +конструктор:    | 
| +Метод1:void     | 
| -Метод2:int      | 
| +Метод3:string   | 


#### Как повысить связность, как понизить связанность?
Применить 4-й принцип из SOLID - Принцип разделения интерфейса (Interface Segregation Principle или ISP): 
много специализированных интерфейсов лучше, чем один универсальный. Другими словами, вам не придется 
реализовать методы, которые вы не используете. Осуществление ISP дает слабую связанность и сильную связность.


****************************************************************************
### **Шаблоны (понимание, обоснование применения): Издатель-подписчик (Publish–subscribe), Одиночка, Фабричный метод, Абстрактная фабрика.**


#### ОДИНОЧКА-Синглтон
https://ru.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%BE%D1%87%D0%BA%D0%B0_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
Одиночка (англ. Singleton) — порождающий шаблон проектирования, гарантирующий, что в однопроцессном 
приложении будет единственный экземпляр некоторого класса, и предоставляющий глобальную точку доступа 
к этому экземпляру.
Использование синглтона не проблема, а признак проблемы. Вот две причины почему:
  - Программы, использующие глобальное состояние очень сложно протестировать;
  - Программы, которые зависят от глобального состояния, скрывают свои зависимости.

Цель применения Синглтон
У класса есть только один экземпляр, и он предоставляет к нему глобальную точку доступа. Существенно то, 
что можно пользоваться именно экземпляром класса, так как при этом во многих случаях становится доступной 
более широкая функциональность. Например, к описанным компонентам класса можно обращаться через интерфейс, 
если такая возможность поддерживается языком.

Глобальный «одинокий» объект — именно объект, а не набор процедур, не привязанных ни к какому 
объекту — бывает нужен:
  - если используется существующая объектно-ориентированная библиотека;
  - если есть шансы, что один объект когда-нибудь превратится в несколько;
  - если интерфейс объекта (например, игрового мира) слишком сложен и не стоит засорять основное пространство имён большим количеством функций;
  - если, в зависимости от каких-нибудь условий и настроек, создаётся один из нескольких объектов. Например, в зависимости от того, ведётся лог или нет, создаётся или настоящий объект, пишущий в файл, или «заглушка», ничего не делающая.
Такие объекты можно создавать и при инициализации программы. Это может приводить к следующим трудностям:
  - Если объект нужен уже при инициализации, он может быть затребован раньше, чем будет создан.
  - Бывает, что объект нужен не всегда. В таком случае его создание можно пропустить.

Плюсы:
  - контролируемый доступ к единственному экземпляру.
Минусы:
  - глобальные объекты могут быть вредны для объектного программирования, в некоторых случаях приводят к созданию немасштабируемого проекта;
  - усложняет написание модульных тестов и следование TDD.

`const Singleton = (function() {
  let instance;

  // Приватные методы и свойства

  // Конструктор
  function Singleton() {
    if (instance) return instance;
    instance = this;
  }

  // Публичные методы
  Singleton.prototype.test = function() {};

  return Singleton;
})();

console.assert(new Singleton() === new Singleton());`
Без использования сокрытия переменных есть простое решение, основанное на том, что функция Singleton является объектом. Минусом является возможность изменения св-ва instance вне класса:

`function Singleton() {
  const instance = Singleton.instance;
  if (instance) return instance;
  Singleton.instance = this;
}

Singleton.prototype.test = function() {};

console.assert(new Singleton() === new Singleton());
Наиболее короткий вариант.

const Singleton = new (function() {
  const instance = this;
  return function() { return instance; };
})();

console.assert(new Singleton() === new Singleton());`

это best practice !!!!!!!!!!!!!!!!!!!!!
function Singleton() {
    if (!Singleton.instance) { 
        Singleton.instance = this;
    }
    return Singleton.instance;  
}


СИЛЬНАЯ СВЯЗАННОСТЬ — это обобщение проблемы синглтона. Одним словом, вы должны уменьшить связь между 
своими модулями. Связанность — это мера того, насколько связаны подпрограммы или модули.
Если внесение изменения в одном модуле в вашем приложении требует, чтобы вы изменили другой модуль, 
тогда связанность существует. Например, вы инстанцируете объекты в классе своего конструктора вместо 
передачи экземпляров как параметров. Это плохо, потому что он не допускает дальнейших изменений, такие 
как замена экземпляра экземпляром подкласса, объектом-mock или что бы то ни было.
Сильно связанные модули трудно повторно использовать, и также сложно тестировать.

Преждевременная оптимизация
Дональд Эрвин Кнут сказал: «преждевременная оптимизация — корень всех зол. Только одни затраты, и 
никакой пользы». Фактически, оптимизированные системы гораздо сложнее, чем просто написание цикла или 
использование преинкремента вместо постинкремента. В конечном итоге, вы останетесь с нечитабельным кодом. 
Именно поэтому Преждевременную Оптимизацию часто считают ошибочной.


паттерн ПОСРЕДНИК определяет интерфейс для обмена информацией с объектами "Коллеги", 
"Конкретный посредник" координирует действия объектов "Коллеги". Каждый класс "Коллеги" знает о своем 
объекте "Посредник", все "Коллеги" обмениваются информацией только с посредником, при его отсутствии 
им пришлось бы обмениваться информацией напрямую. "Коллеги" посылают запросы посреднику и получают 
запросы от него. "Посредник" реализует кооперативное поведение, пересылая каждый запрос одному или 
нескольким "Коллегам".

###№ ФАБРИЧНЫЙ МЕТОД (шаблон проектирования)
(англ. Factory Method также известен как Виртуальный конструктор (англ. Virtual Constructor)) — 
порождающий шаблон проектирования, предоставляющий подклассам интерфейс для создания экземпляров 
некоторого класса. В момент создания наследники могут определить, какой класс создавать. 
Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, какой класс инстанцировать. 
Фабричный метод позволяет классу делегировать создание подклассов. Используется, когда:
  - родительскому классу заранее неизвестно, объекты каких подклассов ему нужно создавать.
  - класс спроектирован так, чтобы объекты, которые он создаёт, специфицировались подклассами.
  - класс делегирует свои обязанности одному из нескольких вспомогательных подклассов, и планируется 
  локализовать знание о том, какой класс принимает эти обязанности на себя
`class Product { GetName() {} }

class ConcreteProductA extends Product { GetName() { return 'ProductA' }
}
class ConcreteProductB extends Product { GetName() { return 'ProductB' }
}
class Creator { FactoryMethod() {}
}
class ConcreteCreatorA extends Creator { FactoryMethod() { return new ConcreteProductA() }
}
class ConcreteCreatorB extends Creator { FactoryMethod() { return new ConcreteProductB() }
}
// An array of creators
const creators = [ new ConcreteCreatorA(), new ConcreteCreatorB() ]
const products = []
// Iterate over creators and create products
for (let creator of creators) {
    products.push(creator.FactoryMethod().GetName())
}
console.log(products)`


#### АБСТРАКТНАЯ ФАБРИКА
https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%B0%D1%8F_%D1%84%D0%B0%D0%B1%D1%80%D0%B8%D0%BA%D0%B0_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
Абстрактная фабрика (англ. Abstract factory) — порождающий шаблон проектирования, предоставляет интерфейс 
для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов. 
Шаблон реализуется созданием абстрактного класса Factory, который представляет собой интерфейс для создания 
компонентов системы (например, для оконного интерфейса он может создавать окна и кнопки). Затем пишутся 
классы, реализующие этот интерфейс.

Предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя 
их конкретных классов.

Плюсы:
  - изолирует конкретные классы;
  - упрощает замену семейств продуктов;
  - гарантирует сочетаемость продуктов.
Минусы:
- сложно добавить поддержку нового вида продуктов.

****************************************************************************
### MVC - Отношения между моделью, вьюхой и контроллером.
*

Node js service view controller
#### CONTROLLER
Занимается рендером, работой с http запросом, отправкой ошибок на клиент, роутингом, версионированием, вызовом сервисов и вьюх
Не занимается бизнес логикой и преобразованием данных
#### VIEW
В данном контексте не типичная mvc view, а класс для преобразования данных для отправки на клиент
Занимается преобразованием json данных для отправки на клиент (удаление лишних полей, форматирование даты)
Не занимается бизнес логикой (фильтрация, сортировка)
#### SERVICE
Занимается бизнес логикой
Не занимается работой с HTTP (например сервис не может выбрасывать 403 статус на клиент)




****************************************************************************
### СОЛИД (SOLID), первые четыре принципа (поверхностное представление).
*
https://habr.com/post/273843/

#### SOLID — термин, описывающий набор принципов разработки для эффективного кода, который был изобретен 
Робертом К. Мартином, также известным как Uncle Bob.

SOLID значит:
  - Принцип единственной обязанности (Single-Responsibility Principle)
  - Принцип открытости/закрытости (Open/Closed Principle, OCP)
  - Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP)
  - Принцип разделения интерфейса (Interface Segregation Principle или ISP) 
  - Внедрение зависимостей (Dependency Injection или DI)

#### Принцип единственной обязанности (Single-Responsibility Principle, SRP) гласит, что 
на каждый класс должна быть возложена одна-единственная обязанность. У класса должна быть только одна 
причина для изменения. 
Разделите большие классы на меньшие и избегайте “божественных” классов. Напишите простые комментарии. Если 
начинаете писать комментарии такие как in this case, but if, except when, or, то вы делаете это неправильно.

#### Принцип открытости/закрытости (Open/Closed Principle, OCP): 
С ущности (классы, модули, функции и т.п.) должны быть открытыми для расширения, но закрытыми для модификации.
Вы должны сделать все переменные экземпляра private по умолчанию. Пишите методы get и set только, когда 
они действительно будут вам нужны.

#### Принцип подстановки Лисков (Liskov Substitution Principle, LSP): 
Должна быть возможность вместо базового типа подставить любой его подтип.
Давайте рассмотрим пример. Прямоугольник — плоская фигура с четырьмя прямыми углами. У него есть ширина (width) 
и высота (height). 
Теперь, взгляните на следующий псевдо-код:

`rect = new Rectangle();
rect.width  = 10;
rect.height = 20;
assert 10 == rect.width
assert 20 == rect.height`

Мы просто устанавливаем ширину width и высоту height на экземпляре Rectangle, и затем мы подтверждаем, что оба 
свойства правильны. Пока все идет хорошо.

Теперь мы можем улучшить наше определение, сообщив, что прямоугольник с четырьмя сторонами одинаковой длины 
называют квадратом. Квадрат — это прямоугольник, таким образом, мы можем создать класс Square, который 
расширяет класс Rectangle, и заменить первую строку, представленную выше, нижней:
rect = new Square();

Согласно определению квадрата, его ширина равна его высоте. Вы можете определить проблему? Первое утверждение 
перестанет работать, потому что мы должны были изменить поведение методов set в классе Square, чтобы 
соответствовать определению. Это нарушение Принципа подстановки Барбары Лисков.

#### Принцип разделения интерфейса (Interface Segregation Principle или ISP): 
много специализированных интерфейсов лучше, чем один универсальный. Другими словами, вам не придется 
реализовать методы, которые вы не используете. Осуществление ISP дает слабую связанность и сильную связность.

Сильная связность означает сохранять подобные и связанные элементы вместе.
Идея состоит в том, чтобы сохранить компоненты ориентированными, и попытаться минимизировать зависимости между ними.

Обратите внимание на то, что это подобно Принципу единственной обязанности (Single-Responsibility). 
Интерфейс — контракт, который удовлетворяет потребности. Нормально иметь класс, который реализует различные 
интерфейсы, но будьте осторожны, не нарушайте SRP.


#### Внедрение зависимостей (Dependency Injection или DI)
имеет два основных положения:
- Абстракции не должны зависеть от деталей.
- Детали должны зависеть от абстракций.

Этот принцип можно перефразировать, как использовать тот же уровень абстракции на заданном уровне. 
Интерфейсы должны зависеть от других интерфейсов. Не добавляйте конкретные классы к сигнатурам методов интерфейса. 
Однако используйте интерфейсы в своих методах класса.

Обратите внимание на то, что Принцип инверсии зависимостей не совпадает с Внедрением зависимостей. 
Внедрение зависимости это когда один объект знает о другом зависимом объекте. Иными словами, речь идет о том, 
как один объект получает зависимость. С другой стороны, Принцип внедрение зависимости заключается в уровне 
абстракции. Кроме того, контейнер внедрения зависимости — это способ для автоматического соединения классов. 
Это не означает, что вы делаете внедрение зависимости все же. Например, взгляните на Service Locator.

Также, вместо того, чтобы работать с классами, которые являются сильно связанными, используйте интерфейсы. 
Это называется программирование интерфейса. Он уменьшает зависимость от особенностей реализации и допускает повторное использование кода. Он также гарантирует, что Вы сможете заменить реализацию, не нарушая ожидания того интерфейса, согласно Принципу подстановки Барбары Лисков.


****************************************************************************
### ОБОБЩЕНИЕ-КОНКРЕТИЗАЦИЯ
*
Идея заключается в том, что по мере того как вы спускаетесь по дереву наследования,
все становится более конкретным. Самое общее располагается на верхушке дере­
ва наследования. Если рассматривать наше дерево наследования Dog , класс с аналогичным названием располагается на 
его верхушке и является наиболее общей категорией. 
Разные породы — классы GoldenRetriever , LhasaApso и Basenji — являются наиболее конкретными. Идея наследования состоит в том, чтобы переходить от общего к частному, выделяя общность.


****************************************************************************
### Проектирование
*
Этапы:
1) Составление технического задания - должно обеспечить полное понимание системы для любого человека
2) Определение классов - самый простой способ определить классы — выделить все существительные.
проектирование является итеративным процессом
3) Определение ответственности каждого класса - Сюда входят данные, которые должен содержать класс, 
а также операции, которые он должен выполнять.
4) Определение взаимодействия классов друг с другом
менно здесь находят свое применение со-
общения между классами. Один класс может отправить сообщение другому, когда
ему нужна информация из этого класса либо требуется, чтобы другой класс что-то
сделал для него.
5) Создание модели классов для описания системы
Модель классов показывает, как разные классы взаимодействуют в рамках
системы.
6) Прототипирование интерфейса пользователя
7) Структурированный код
Три базовые концепции структурного программирования: последовательность, условия
и итерации.
В ООП: Объект -> метод -> структурированный код

Разработчики программного обеспечения часто применяют код, написанный
кем-то другим. Это может быть код, приобретенный у поставщика или даже на-
писанный людьми из той же организации. Во многих случаях оказывается, что код
нельзя изменить. Возможно, из-за того, что человек, написавший код, больше не
работает в организации либо поставщик не может предоставить пакеты обновлений
и т. д. Именно в таких ситуациях проявляется истинная мощь оберток.


