# Backend developer checklist (все по ООП, подчернутые в приоритете)

****************************************************************************
## Stage 1, part 2 
## ООП
Вопросы в этом разделе:
  * Шаблоны (понимание, обоснование применения): Издатель-подписчик (Publish–subscribe),  Одиночка, Фабричный метод, Абстрактная фабрика.
  * MVC - Отношения между моделью, вьюхой и контроллером.
  * СОЛИД, первые четыре принципа (поверхностное представление).

****************************************************************************

### **Объект** 
— это именованная сущность, одновременно содержащая данные(свойства) и поведения(методы).
Слово «одновременно» в данном случае определяет ключевую разницу между ООП и 
другими методологиями программирования. Например, при процедурном программировании 
код размещается в полностью отдельных функциях или процедурах.

**Класс** - это шаблон, предназначенный для создания объектов.
Класс - это именованная сущность из предметной области, возможно, имеющая 
предка (суперкласс), определенная как набор полей и методов.

В JavaScript классы можно организовать по-разному. Говорят, что класс User написан 
в «функциональном» стиле. Далее мы также увидим «прототипный» стиль.


****************************************************************************
### **Шаблоны (понимание, обоснование применения): Издатель-подписчик (Publish–subscribe), Одиночка, Фабричный метод, Абстрактная фабрика.**


#### ОДИНОЧКА-Синглтон
https://ru.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%BE%D1%87%D0%BA%D0%B0_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
Одиночка (англ. Singleton) — порождающий шаблон проектирования, гарантирующий, что в однопроцессном 
приложении будет единственный экземпляр некоторого класса, и предоставляющий глобальную точку доступа 
к этому экземпляру.
Использование синглтона не проблема, а признак проблемы. Вот две причины почему:
  - Программы, использующие глобальное состояние очень сложно протестировать;
  - Программы, которые зависят от глобального состояния, скрывают свои зависимости.

Цель применения Синглтон
У класса есть только один экземпляр, и он предоставляет к нему глобальную точку доступа. Существенно то, 
что можно пользоваться именно экземпляром класса, так как при этом во многих случаях становится доступной 
более широкая функциональность. Например, к описанным компонентам класса можно обращаться через интерфейс, 
если такая возможность поддерживается языком.

Глобальный «одинокий» объект — именно объект, а не набор процедур, не привязанных ни к какому 
объекту — бывает нужен:
  - если используется существующая объектно-ориентированная библиотека;
  - если есть шансы, что один объект когда-нибудь превратится в несколько;
  - если интерфейс объекта (например, игрового мира) слишком сложен и не стоит засорять основное пространство имён большим количеством функций;
  - если, в зависимости от каких-нибудь условий и настроек, создаётся один из нескольких объектов. Например, в зависимости от того, ведётся лог или нет, создаётся или настоящий объект, пишущий в файл, или «заглушка», ничего не делающая.
Такие объекты можно создавать и при инициализации программы. Это может приводить к следующим трудностям:
  - Если объект нужен уже при инициализации, он может быть затребован раньше, чем будет создан.
  - Бывает, что объект нужен не всегда. В таком случае его создание можно пропустить.

Плюсы:
  - контролируемый доступ к единственному экземпляру.

Минусы:
  - глобальные объекты могут быть вредны для объектного программирования, в некоторых случаях приводят к созданию немасштабируемого проекта;
  - усложняет написание модульных тестов и следование TDD.

```
const Singleton = (function() {
  let instance;

  // Приватные методы и свойства

  // Конструктор
  function Singleton() {
    if (instance) return instance;
    instance = this;
  }

  // Публичные методы
  Singleton.prototype.test = function() {};

  return Singleton;
})();

console.assert(new Singleton() === new Singleton());
```
Без использования сокрытия переменных есть простое решение, основанное на том, что функция Singleton является объектом. Минусом является возможность изменения св-ва instance вне класса:

```
function Singleton() {
  const instance = Singleton.instance;
  if (instance) return instance;
  Singleton.instance = this;
}

Singleton.prototype.test = function() {};

console.assert(new Singleton() === new Singleton());
```
Наиболее короткий вариант.
```
const Singleton = new (function() {
  const instance = this;
  return function() { return instance; };
})();

console.assert(new Singleton() === new Singleton());
```

#### это best practice !!!!!!!!!!!!!!!!!!!!!
```
function Singleton() {
    if (!Singleton.instance) { 
        Singleton.instance = this;
    }
    return Singleton.instance;  
}
```
СИЛЬНАЯ СВЯЗАННОСТЬ — это обобщение проблемы синглтона. Одним словом, вы должны уменьшить связь между 
своими модулями. Связанность — это мера того, насколько связаны подпрограммы или модули.
Если внесение изменения в одном модуле в вашем приложении требует, чтобы вы изменили другой модуль, 
тогда связанность существует. Например, вы инстанцируете объекты в классе своего конструктора вместо 
передачи экземпляров как параметров. Это плохо, потому что он не допускает дальнейших изменений, такие 
как замена экземпляра экземпляром подкласса, объектом-mock или что бы то ни было.
Сильно связанные модули трудно повторно использовать, и также сложно тестировать.

Преждевременная оптимизация
Дональд Кнут сказал: «преждевременная оптимизация — корень всех зол. Только одни затраты, и никакой 
пользы». Фактически, оптимизированные системы гораздо сложнее, чем просто написание цикла или 
использование преинкремента вместо постинкремента. В конечном итоге, вы останетесь с нечитабельным 
кодом. Именно поэтому Преждевременную Оптимизацию часто считают ошибочной.

паттерн ПОСРЕДНИК определяет интерфейс для обмена информацией с объектами "Коллеги", 
"Конкретный посредник" координирует действия объектов "Коллеги". Каждый класс "Коллеги" знает о своем 
объекте "Посредник", все "Коллеги" обмениваются информацией только с посредником, при его отсутствии 
им пришлось бы обмениваться информацией напрямую. "Коллеги" посылают запросы посреднику и получают 
запросы от него. "Посредник" реализует кооперативное поведение, пересылая каждый запрос одному или 
нескольким "Коллегам".

#### ФАБРИЧНЫЙ МЕТОД (шаблон проектирования)
(англ. Factory Method также известен как Виртуальный конструктор (англ. Virtual Constructor)) — 
порождающий шаблон проектирования, предоставляющий подклассам интерфейс для создания экземпляров 
некоторого класса. В момент создания наследники могут определить, какой класс создавать. 
Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, какой класс инстанцировать. 
Фабричный метод позволяет классу делегировать создание подклассов. Используется, когда:
  - родительскому классу заранее неизвестно, объекты каких подклассов ему нужно создавать.
  - класс спроектирован так, чтобы объекты, которые он создаёт, специфицировались подклассами.
  - класс делегирует свои обязанности одному из нескольких вспомогательных подклассов, и планируется 
  локализовать знание о том, какой класс принимает эти обязанности на себя

https://refactoring.guru/ru/design-patterns/factory-method

```
class Product { GetName() {} }

class ConcreteProductA extends Product { GetName() { return 'ProductA' } }
class ConcreteProductB extends Product { GetName() { return 'ProductB' } }
class Creator { FactoryMethod() {} }
class ConcreteCreatorA extends Creator { FactoryMethod() { return new ConcreteProductA() } }
class ConcreteCreatorB extends Creator { FactoryMethod() { return new ConcreteProductB() } }
// An array of creators
const creators = [ new ConcreteCreatorA(), new ConcreteCreatorB() ]
const products = []
// Iterate over creators and create products
for (let creator of creators) {
    products.push(creator.FactoryMethod().GetName())
}
console.log(products)
```
... и в новом варианте, а-ля TypeScript, но без указания типов:
```
interface SocialHubConnect { PushNewPost() {} }

class VkHTTP implements SocialHubConnect { PushNewPost(newPost) {  return axios.get(newPost); } }
class VkGraphQL implements SocialHubConnect { PushNewPost(newPost) { return axios.gql(newPost); } }
class FacebookGraphQL implements SocialHubConnect { 
    PushNewPost(newPost) { return axios.gql(newPost); } 
}

class FactoryCreator { public abstract SocialConnect() {} }

class HTTPFactoryCreator extends FactoryCreator { 
  SocialConnect() { return new VkHTTP() } 
}
class GraphQLFactoryCreator extends FactoryCreator { 
  SocialConnect() { return new VkGraphQL() } 
}
class GraphQLFacebookFactoryCreator extends FactoryCreator { 
  SocialConnect() { return new FacebookGraphQL() } 
}

// An array of creators
const advertizingChannels = [ new HTTPFactoryCreator()
    , new GraphQLFactoryCreator()
    , new GraphQLFacebookFactoryCreator() 
    ]
// Iterate over creators and make newPost for all advertizing channels
for (let point of advertizingChannels) {
    point.SocialConnect().PushNewPost('newPost - Hello world');
}
```


#### АБСТРАКТНАЯ ФАБРИКА
https://refactoring.guru/ru/design-patterns/abstract-factory
https://refactoring.guru/ru/design-patterns/factory-comparison 

https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%B0%D1%8F_%D1%84%D0%B0%D0%B1%D1%80%D0%B8%D0%BA%D0%B0_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)

Абстрактная фабрика (англ. Abstract factory) — порождающий шаблон проектирования, предоставляет интерфейс 
для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов. 
Шаблон реализуется созданием абстрактного класса Factory, который представляет собой интерфейс для создания 
компонентов системы (например, для оконного интерфейса он может создавать окна и кнопки). Затем пишутся 
классы, реализующие этот интерфейс.

Предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя 
их конкретных классов.

Плюсы:
  - изолирует конкретные классы;
  - упрощает замену семейств продуктов;
  - гарантирует сочетаемость продуктов.

Минусы:
- сложно добавить поддержку нового вида продуктов.


****************************************************************************
### MVC - Отношения между моделью, вьюхой и контроллером.
*

Node js service view controller
#### CONTROLLER
Занимается рендером, работой с http запросом, отправкой ошибок на клиент, роутингом, версионированием, вызовом сервисов и вьюх
Не занимается бизнес логикой и преобразованием данных
#### VIEW
В данном контексте не типичная mvc view, а класс для преобразования данных для отправки на клиент
Занимается преобразованием json данных для отправки на клиент (удаление лишних полей, форматирование даты)
Не занимается бизнес логикой (фильтрация, сортировка)
#### SERVICE
Занимается бизнес логикой
Не занимается работой с HTTP (например сервис не может выбрасывать 403 статус на клиент)


****************************************************************************
### СОЛИД (SOLID), первые четыре принципа (поверхностное представление).
*
https://habr.com/post/273843/

#### SOLID — термин, описывающий набор принципов разработки для эффективного кода, который был изобретен 
Робертом К. Мартином, также известным как Uncle Bob.

SOLID значит:
  - Принцип единственной обязанности (Single-Responsibility Principle)
  - Принцип открытости/закрытости (Open/Closed Principle, OCP)
  - Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP)
  - Принцип разделения интерфейса (Interface Segregation Principle или ISP) 
  - Внедрение зависимостей (Dependency Injection/inversion или DI)

#### S — Single responsibility — Принцип единственной ответственности/обязанности
«На каждый объект должна быть возложена одна единственная обязанность». 
Т.е. другими словами — конкретный класс должен решать конкретную задачу — ни больше, ни меньше.
У класса должна быть только одна причина для изменения. 
Разделите большие классы на меньшие и избегайте “божественных” классов. Напишите простые комментарии. Если 
начинаете писать комментарии такие как in this case, but if, except when, or, то вы делаете это неправильно.

#### O — Open-closed — Принцип открытости/закрытости 
"программные сущности должны быть открыты для расширения, но закрыты для модификации". 
Т.е. все классы, функции и т.д. должны проектироваться так, чтобы для изменения их поведения, 
нам не нужно было изменять их исходный код.
Вы должны сделать все переменные экземпляра private по умолчанию. Пишите методы get и set 
только, когда они действительно будут вам нужны.

#### L — Liskov substitution — Принцип подстановки Барбары Лисков
«Объекты в программе могут быть заменены их наследниками без изменения свойств программы». Своими словами я бы это сказал так — при использовании наследника класса результат выполнения кода должен быть предсказуем и не изменять свойств метод.
Проектирование по контракту ведет к некоторым ограничениям на то, как контракты могут взаимодействовать с наследованием, а именно:
Предусловия не могут быть усилены в подклассе.
Постусловия не могут быть ослаблены в подклассе.
Предусловия – это то, что должно быть выполнено вызывающей стороной перед вызовом метода, постусловия – это то, что, гарантируется вызываемым методом.
Должна быть возможность вместо базового типа подставить любой его подтип.
Давайте рассмотрим пример. Прямоугольник — плоская фигура с четырьмя прямыми углами. У него есть ширина (width) 
и высота (height). 
Теперь, взгляните на следующий псевдо-код:

```
rect = new Rectangle();
rect.width  = 10;
rect.height = 20;
assert 10 == rect.width
assert 20 == rect.height
```

Мы просто устанавливаем ширину width и высоту height на экземпляре Rectangle, и затем мы подтверждаем, что оба 
свойства правильны. Пока все идет хорошо.

Теперь мы можем улучшить наше определение, сообщив, что прямоугольник с четырьмя сторонами одинаковой длины 
называют квадратом. Квадрат — это прямоугольник, таким образом, мы можем создать класс Square, который 
расширяет класс Rectangle, и заменить первую строку, представленную выше, нижней:
rect = new Square();

Согласно определению квадрата, его ширина равна его высоте. Вы можете определить проблему? Первое утверждение 
перестанет работать, потому что мы должны были изменить поведение методов set в классе Square, чтобы 
соответствовать определению. Это нарушение Принципа подстановки Барбары Лисков.

#### I — Interface segregation — Принцип разделения интерфейса 
«Много специализированных интерфейсов лучше, чем один универсальный»
Соблюдение этого принципа необходимо для того, чтобы классы-клиенты, использующий/реализующий интерфейс, 
знали только о тех методах, которые они используют, что ведёт к уменьшению количества неиспользуемого кода.
Вам не придется реализовать методы, которые вы не используете. 
Осуществление ISP дает слабую связанность и сильную связность.

Сильная связность означает сохранять подобные и связанные элементы вместе. Идея состоит в том, 
чтобы сохранить компоненты ориентированными, и попытаться минимизировать зависимости между ними.

Обратите внимание на то, что это подобно Принципу единственной обязанности (Single-Responsibility). 
Интерфейс — контракт, который удовлетворяет потребности. Нормально иметь класс, который реализует 
различные интерфейсы, но будьте осторожны, не нарушайте SRP.

#### D — Dependency Invertion — Принцип инверсии зависимостей 
«Зависимости внутри системы строятся на основе абстракций. Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций». Данное определение можно сократить — «зависимости должны строится относительно абстракций, а не деталей».

Этот принцип можно перефразировать, как использовать тот же уровень абстракции на заданном уровне. 
Интерфейсы должны зависеть от других интерфейсов. Не добавляйте конкретные классы к сигнатурам методов интерфейса. 
Однако используйте интерфейсы в своих методах класса.

Обратите внимание на то, что Принцип инверсии зависимостей не совпадает с Внедрением зависимостей. 
Внедрение зависимости это когда один объект знает о другом зависимом объекте. Иными словами, речь идет о том, 
как один объект получает зависимость. С другой стороны, Принцип внедрение зависимости заключается в уровне 
абстракции. Кроме того, контейнер внедрения зависимости — это способ для автоматического соединения классов. 
Это не означает, что вы делаете внедрение зависимости все же. Например, взгляните на Service Locator.

Также, вместо того, чтобы работать с классами, которые являются сильно связанными, используйте интерфейсы. 
Это называется программирование интерфейса. Он уменьшает зависимость от особенностей реализации и допускает повторное использование кода. Он также гарантирует, что Вы сможете заменить реализацию, не нарушая ожидания того интерфейса, согласно Принципу подстановки Барбары Лисков.


****************************************************************************
### ОБОБЩЕНИЕ-КОНКРЕТИЗАЦИЯ
*
Идея заключается в том, что по мере того как вы спускаетесь по дереву наследования,
все становится более конкретным. Самое общее располагается на верхушке дере­
ва наследования. Если рассматривать наше дерево наследования Dog , класс с аналогичным названием 
располагается на 
его верхушке и является наиболее общей категорией. 
Разные породы — классы GoldenRetriever , LhasaApso и Basenji — являются наиболее конкретными. 
Идея наследования состоит в том, чтобы переходить от общего к частному, выделяя общность.


****************************************************************************
### Проектирование
*
Этапы:
1) Составление технического задания - должно обеспечить полное понимание системы для любого человека
2) Определение классов - самый простой способ определить классы — выделить все существительные.
проектирование является итеративным процессом
3) Определение ответственности каждого класса - Сюда входят данные, которые должен содержать класс, 
а также операции, которые он должен выполнять.
4) Определение взаимодействия классов друг с другом
менно здесь находят свое применение со-
общения между классами. Один класс может отправить сообщение другому, когда
ему нужна информация из этого класса либо требуется, чтобы другой класс что-то
сделал для него.
5) Создание модели классов для описания системы
Модель классов показывает, как разные классы взаимодействуют в рамках
системы.
6) Прототипирование интерфейса пользователя
7) Структурированный код
Три базовые концепции структурного программирования: последовательность, условия
и итерации.
В ООП: Объект -> метод -> структурированный код

Разработчики программного обеспечения часто применяют код, написанный
кем-то другим. Это может быть код, приобретенный у поставщика или даже на-
писанный людьми из той же организации. Во многих случаях оказывается, что код
нельзя изменить. Возможно, из-за того, что человек, написавший код, больше не
работает в организации либо поставщик не может предоставить пакеты обновлений
и т. д. Именно в таких ситуациях проявляется истинная мощь оберток.


****************************************************************************
## Базы данных
**ТРАНЗАКЦИЯ** - это цепочка объединенных запросов, которая или выполняется полностью или не выполняется вообще.

****************************************************************************
### Типы данных в PostgreSQL
*
https://postgrespro.ru/docs/postgrespro/9.6/datatype

Преобразования типов real и double precision так же возможны через тип numeric, например:
```
SELECT '12.34'::float8::numeric::money;

CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
```
Порядок значений в перечислении определяется последовательностью, в которой были указаны значения при создании типа. Перечисления поддерживаются всеми стандартными операторами сравнения и связанными агрегатными функциями. Например:
```
INSERT INTO person VALUES ('Larry', 'sad');
INSERT INTO person VALUES ('Curly', 'ok');
SELECT * FROM person WHERE current_mood > 'sad';
 name  | current_mood 
-------+--------------
 Moe   | happy
 Curly | ok
(2 rows)
```
Существуют два типа данных JSON: json и jsonb. Они принимают на вход почти одинаковые наборы значений, но основное их отличие в эффективности. Тип json сохраняет точную копию введённого текста, которую функции обработки должны разбирать заново при каждом выполнении, тогда как данные jsonb сохраняются в разобранном двоичном формате, что несколько замедляет ввод из-за преобразования, но значительно ускоряет обработку, не требуя многократного разбора текста. Кроме того, jsonb поддерживает индексацию, что тоже может быть очень полезно.
```
-- Массив из нуля и более элементов (элементы могут быть разных типов)
SELECT '[1, 2, "foo", null]'::json;

-- Объект, содержащий пары ключей и значений
-- Заметьте, что ключи объектов — это всегда строки в кавычках
SELECT '{"bar": "baz", "balance": 7.77, "active": false}'::json;
```
Проверки на вхождение и существование jsonb
Проверка вхождения — важная особенность типа jsonb, не имеющая аналога для типа json. Эта проверка определяет, входит ли один документ jsonb в другой. В следующих примерах возвращается истинное значение (кроме упомянутых исключений):
```
-- Простые скалярные/примитивные значения включают только одно идентичное значение:
SELECT '"foo"'::jsonb @> '"foo"'::jsonb;

-- Массив с правой стороны входит в массив слева:
SELECT '[1, 2, 3]'::jsonb @> '[1, 3]'::jsonb;

-- Порядок элементов в массиве не важен, поэтому это условие тоже выполняется:
SELECT '[1, 2, 3]'::jsonb @> '[3, 1]'::jsonb;

-- А повторяющиеся элементы массива не имеют значения:
SELECT '[1, 2, 3]'::jsonb @> '[1, 2, 2]'::jsonb;
```
Обращение к массивам
Этот запрос получает имена сотрудников, зарплата которых изменилась во втором квартале:
```
SELECT name FROM sal_emp WHERE pay_by_quarter[1] <> pay_by_quarter[2];

 name
-------
 Carol
(1 row)
```
#### По умолчанию в Postgres Pro действует соглашение о нумерации элементов массива с 1, то есть в массиве из n элементов первым считается array[1], а последним — array[n].
этот запрос получает первые пункты в графике Билла в первые два дня недели:
```
SELECT schedule[1:2][1:1] FROM sal_emp WHERE name = 'Bill';

        schedule
------------------------
 {{meeting},{training}}
(1 row)
```


**Полнотекстовый поиск** (или просто поиск текста) — это возможность находить документы на естественном языке, соответствующие запросу, и, возможно, дополнительно сортировать их по релевантности для этого запроса. Наиболее распространённая задача — найти все документы, содержащие слова запроса, и выдать их отсортированными по степени соответствия запросу.  
Тип **tsvector** представляет документ в виде, оптимизированном для текстового поиска, а **tsquery** представляет 
запрос текстового поиска в подобном виде.
Полнотекстовая индексация заключается в предварительной обработке документов и сохранении индекса для последующего быстрого поиска. Предварительная обработка включает следующие операции:

Разбор документов на фрагменты. При этом полезно выделить различные классы фрагментов, например, числа, слова, словосочетания, почтовые адреса и т. д., которые будут обрабатываться по-разному. В принципе классы фрагментов могут зависеть от приложения, но для большинства применений вполне подойдёт предопределённый набор классов. Эту операцию в Postgres Pro выполняет анализатор (parser). Вы можете использовать как стандартный анализатор, так и создавать свои, узкоспециализированные.

Преобразование фрагментов в лексемы. Лексема — это нормализованный фрагмент, в котором разные словоформы приведены к одной. Например, при нормализации буквы верхнего регистра приводятся к нижнему, а из слов обычно убираются окончания (в частности, s или es в английском). Благодаря этому можно находить разные формы одного слова, не вводя вручную все возможные варианты. Кроме того, на данном шаге обычно исключаются стоп-слова, то есть слова, настолько распространённые, что искать их нет смысла. (Другими словами, фрагменты представляют собой просто подстроки текста документа, а лексемы — это слова, имеющие ценность для индексации и поиска.) Для выполнения этого шага в Postgres Pro используются словари. Набор существующих стандартных словарей при необходимости можно расширять, создавая свои собственные.

Хранение документов в форме, подготовленной для поиска. Например, каждый документ может быть представлен в виде сортированного массива нормализованных лексем. Помимо лексем часто желательно хранить информацию об их положении для ранжирования по близости, чтобы документ, в котором слова запроса расположены «плотнее», получал более высокий ранг, чем документ с разбросанными словами.

**ДОКУМЕНТ** — это единица обработки в системе полнотекстового поиска; например, журнальная статья или почтовое сообщение. Система поиска текста должна уметь разбирать документы и сохранять связи лексем (ключевых слов) с содержащим их документом. Впоследствии эти связи могут использоваться для поиска документов с заданными ключевыми словами.

В контексте поиска в Postgres Pro документ — это обычно содержимое текстового поля в строке таблицы или, возможно, сочетание (объединение) таких полей, которые могут храниться в разных таблицах или формироваться динамически. Другими словами, документ для индексации может создаваться из нескольких частей и не храниться где-либо как единое целое. 
Например:
```
SELECT title || ' ' ||  author || ' ' ||  abstract || ' ' || body
  AS document
FROM messages
WHERE mid = 12;

SELECT m.title || ' ' || m.author || ' ' || m.abstract || ' ' || d.body
  AS document
FROM messages m, docs d
WHERE mid = did AND mid = 12;
```
Примечание
На самом деле в этих примерах запросов следует использовать функцию coalesce, чтобы значение NULL в каком-либо одном атрибуте не привело к тому, что результирующим документом окажется NULL.



****************************************************************************
### Связи между таблицами
*

****************************************************************************
### Первичные и внешние ключи
*
https://postgrespro.ru/docs/postgrespro/9.6/ddl-constraints#ddl-constraints-fk

Ограничение внешнего ключа указывает, что значения столбца (или группы столбцов) должны соответствовать значениям в некоторой строке другой таблицы. Это называется ссылочной целостностью двух связанных таблиц.
```
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer REFERENCES products,
    quantity integer
);
```
С таким ограничением создать заказ со значением product_no, отсутствующим в таблице products (и не равным NULL), будет невозможно.

В такой схеме таблицу orders называют подчинённой таблицей, а products — главной. Соответственно, столбцы называют так же подчинённым и главным (или ссылающимся и целевым).
Внешний ключ будет неявно связан с первичным ключом главной таблицы.

Внешний ключ также может ссылаться на группу столбцов. В этом случае его нужно записать в виде обычного ограничения таблицы. Например:
```
CREATE TABLE t1 (
  a integer PRIMARY KEY,
  b integer,
  c integer,
  FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)
);
```
Естественно, число и типы столбцов в ограничении должны соответствовать числу и типам целевых столбцов.


****************************************************************************
### CRUD операции
Create
Read
Update
Delete
*
#### Create
```
CREATE TABLE имя_таблицы (
    имя_столбца SERIAL
);
```
равнозначна следующим командам:
```
CREATE SEQUENCE имя_таблицы_имя_столбца_seq;
CREATE TABLE имя_таблицы (
    имя_столбца integer NOT NULL DEFAULT nextval('имя_таблицы_имя_столбца_seq')
);
ALTER SEQUENCE имя_таблицы_имя_столбца_seq OWNED BY имя_таблицы.имя_столбца;
```
```
CREATE TABLE test1 (a character(4));
INSERT INTO test1 VALUES ('ok');
SELECT a, char_length(a) FROM test1; -- (1)

  a   | char_length
------+-------------
 ok   |           2


CREATE TABLE test2 (b varchar(5));
INSERT INTO test2 VALUES ('ok');
INSERT INTO test2 VALUES ('good      ');
INSERT INTO test2 VALUES ('too long');
ОШИБКА:  значение не умещается в тип character varying(5)
INSERT INTO test2 VALUES ('too long'::varchar(5)); -- явное усечение
SELECT b, char_length(b) FROM test2;

   b   | char_length
-------+-------------
 ok    |           2
 good  |           5
 too l |           5
```

```
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text UNIQUE,
    price numeric NOT NULL CHECK (price > 0),
    discounted_price numeric CHECK (discounted_price > 0),
    CHECK (price > discounted_price)
);
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer REFERENCES products (product_no),
    quantity integer
);
CREATE TABLE t1 (
  a integer PRIMARY KEY,
  b integer,
  c integer,
  FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)
);
```
Внешний ключ также может ссылаться на группу столбцов. В этом случае его нужно записать в виде обычного 
ограничения таблицы. Число и типы столбцов в ограничении должны соответствовать числу и типам целевых столбцов.
```
CREATE TABLE order_items (
    product_no integer REFERENCES products,
    order_id integer REFERENCES orders,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
```
В последней таблице первичный ключ покрывает внешние ключи.



#### Read
SELECT, TABLE, WITH — получить строки из таблицы или представления
https://postgrespro.ru/docs/postgrespro/9.6/sql-select
```
SELECT [ ALL | DISTINCT [ ON ( выражение [, ...] ) ] ]
    [ * | выражение [ [ AS ] имя_результата ] [, ...] ]
    [ FROM элемент_FROM [, ...] ]
    [ WHERE условие ]
    [ GROUP BY элемент_группирования [, ...] ]
    [ HAVING условие [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] выборка ]
    [ ORDER BY выражение [ ASC | DESC | USING оператор ] [ NULLS { FIRST | LAST } ] [, ...] ]

```
**SELECT ALL** (по умолчанию) возвращает все строки результата, включая дубликаты.
SELECT DISTINCT исключает из результата повторяющиеся строки. SELECT DISTINCT ON исключает строки, 
совпадающие по всем указанным выражениям. 
Операторы **UNION, INTERSECT и EXCEPT** объединяют вывод нескольких команд SELECT в один результирующий набор. 
Оператор UNION возвращает все строки, представленные в одном, либо обоих наборах результатов. 
Оператор INTERSECT возвращает все строки, представленные строго в обоих наборах. 
Оператор EXCEPT возвращает все строки, представленные в первом наборе, но не во втором. Во всех трёх случаях повторяющиеся строки исключаются из результата, если явно не указано ALL. 
Если присутствует предложение **ORDER BY**, возвращаемые строки сортируются в указанном порядке. 
В отсутствие ORDER BY строки возвращаются в том порядке, в каком системе будет проще их выдать. (См. Предложение ORDER BY ниже.)
Если указано предложение **LIMIT** (или FETCH FIRST) либо OFFSET, оператор SELECT возвращает только подмножество строк результата. (См. Предложение LIMIT ниже.)
Предложение **WITH** позволяет задать один или несколько подзапросов, к которым затем можно обратиться по имени в основном запросе. Эти подзапросы по сути действуют как временные таблицы или представления в процессе выполнения главного запроса. Каждый подзапрос может представлять собой оператор SELECT, TABLE, VALUES, INSERT, UPDATE или DELETE.
В предложении **FROM** перечисляются одна или несколько таблиц, служащих источниками данных для SELECT.
**ON условие_соединения**
Задаваемое условие_соединения представляет собой выражение, выдающее значение типа boolean (как в предложении WHERE), которое определяет, какие строки считаются соответствующими при соединении.

**USING ( столбец_соединения [, ...] )**
Предложение вида USING ( a, b, ... ) представляет собой сокращённую форму записи ON таблица_слева.a = таблица_справа.a AND таблица_слева.b = таблица_справа.b .... Кроме того, USING подразумевает, что в результат соединения будет включён только один из пары равных столбцов, но не оба.



#### Update
Добавить столбец вы можете так:
```
ALTER TABLE products ADD COLUMN description text;
```

Удалить столбец можно так:
```
ALTER TABLE products DROP COLUMN description;
```
```
ALTER TABLE [ IF EXISTS ] имя RENAME TO новое_имя
ALTER TABLE [ IF EXISTS ] имя [ * ] действие [, ... ]
ALTER TABLE [ IF EXISTS ] имя [ * ] DROP [ COLUMN ] [ IF EXISTS ] имя_столбца [ RESTRICT | CASCADE ]
ALTER TABLE [ IF EXISTS ] имя [ * ] ALTER [ COLUMN ] имя_столбца SET ( атрибут = значение [, ... ] )
```



#### Delete


****************************************************************************
### JOIN'ы
*
https://postgrespro.ru/docs/postgrespro/9.6/sql-select

Для типов соединений **INNER** и OUTER необходимо указать условие соединения, а именно одно из предложений NATURAL, ON условие_соединения или USING (столбец_соединения [, ...]). Эти предложения описываются ниже. Для CROSS JOIN ни одно из этих предложений не допускается.

Предложение JOIN объединяет два элемента списка FROM, которые мы для простоты дальше будем называть «таблицами», хотя на самом деле это может быть любой объект, допустимый в качестве элемента FROM. Для определения порядка вложенности при необходимости следует использовать скобки. В отсутствие скобок предложения JOIN обрабатывается слева направо. В любом случае, JOIN связывает элементы сильнее, чем запятые, разделяющие элементы в списке FROM.

**CROSS JOIN и INNER JOIN** формируют простое декартово произведение, то же, что можно получить, указав две таблицы на верхнем уровне FROM, но ограниченное возможным условием соединения. Предложение CROSS JOIN равнозначно INNER JOIN ON (TRUE), то есть, никакие строки по условию не удаляются. Эти типы соединений введены исключительно для удобства записи, они не дают ничего такого, что нельзя было бы получить, используя просто FROM и WHERE.

**LEFT OUTER JOIN** возвращает все строки ограниченного декартова произведения (т. е. все объединённые строки, удовлетворяющие условию соединения) плюс все строки в таблице слева, для которых не находится строк в таблице справа, удовлетворяющих условию. Строка, взятая из таблицы слева, дополняется до полной ширины объединённой таблицы значениями NULL в столбцах таблицы справа. Заметьте, что для определения, какие строки двух таблиц соответствуют друг другу, проверяется только условие самого предложения JOIN. Внешние условия проверяются позже.

**RIGHT OUTER JOIN**, напротив, возвращает все соединённые строки плюс одну строку для каждой строки справа, не имеющей соответствия слева (эта строка дополняется значениями NULL влево). Это предложение введено исключительно для удобства записи, так как его можно легко свести к LEFT OUTER JOIN, поменяв левую и правую таблицы местами.

**FULL OUTER JOIN** возвращает все соединённые строки плюс все строки слева, не имеющие соответствия справа, (дополненные значениями NULL вправо) плюс все строки справа, не имеющие соответствия слева (дополненные значениями NULL влево).


****************************************************************************
### Группировка, агрегатные (агрегирующе) функции
*
https://postgrespro.ru/docs/postgrespro/9.6/sql-select

Предложение GROUP BY
Необязательное предложение GROUP BY имеет общую форму

GROUP BY элемент_группирования [, ...]
GROUP BY собирает в одну строку все выбранные строки, выдающие одинаковые значения для выражений группировки. В качестве выражения внутри элемента_группирования может выступать имя входного столбца, либо имя или порядковый номер выходного столбца (из списка элементов SELECT), либо произвольное значение, вычисляемое по значениям входных столбцов. В случае неоднозначности имя в GROUP BY будет восприниматься как имя входного, а не выходного столбца.

Если в элементе группирования задаётся GROUPING SETS, ROLLUP или CUBE, предложение GROUP BY в целом определяет некоторое число независимых наборов группирования. Это даёт тот же эффект, что и объединение подзапросов (с UNION ALL) с отдельными наборами группирования в их предложениях GROUP BY. Подробнее использование наборов группирования описывается в Подразделе 7.2.4.

Агрегатные функции, если они используются, вычисляются по всем строкам, составляющим каждую группу, и в итоге выдают отдельное значение для каждой группы. (Если агрегатные функции используются без предложения GROUP BY, запрос выполняется как с одной группой, включающей все выбранные строки.) Набор строк, поступающих в каждую агрегатную функцию, можно дополнительно отфильтровать, добавив предложение FILTER к вызову агрегатной функции; за дополнительными сведениями обратитесь к Подразделу 4.2.7. С предложением FILTER на вход агрегатной функции поступают только те строки, которые соответствуют заданному фильтру.

Когда в запросе присутствует предложение GROUP BY или какая-либо агрегатная функция, выражения в списке SELECT не могут обращаться к негруппируемым столбцам, кроме как в агрегатных функциях или в случае функциональной зависимости, так как иначе в негруппируемом столбце нужно было бы вернуть более одного возможного значения. Функциональная зависимость образуется, если группируемые столбцы (или их подмножество) составляют первичный ключ таблицы, содержащей негруппируемый столбец.

Имейте в виду, что все агрегатные функции вычисляются перед «скалярными» выражениями в предложении HAVING или списке SELECT. Это значит, что например, с помощью выражения CASE нельзя обойти вычисление агрегатной функции; см. Подраздел 4.2.14.

В настоящее время указания FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE и FOR KEY SHARE нельзя задать вместе с GROUP BY.


****************************************************************************
### Сортировка
*
https://postgrespro.ru/docs/postgrespro/9.6/sql-select

Предложение ORDER BY
Необязательное предложение ORDER BY имеет следующую общую форму:

ORDER BY выражение [ ASC | DESC | USING оператор ] [ NULLS { FIRST | LAST } ] [, ...]
Предложение ORDER BY указывает, что строки результата должны сортироваться согласно заданным выражениям. Если две строки дают равные значения для самого левого выражения, проверяется следующее выражение и т. д. Если их значения оказываются равными для всех заданных выражений, строки возвращаются в порядке, определяемом реализацией.

В качестве выражения может задаваться имя или порядковый номер выходного столбца (элемента списка SELECT), либо произвольное выражение со значениями входных столбцов.

Порядковым номером в данном случае считается последовательный номер (при нумерации слева направо) позиции выходного столбца. Возможность указать порядковый номер позволяет выполнить сортировку по столбцу, не имеющему уникального имени. В принципе это не абсолютно необходимо, так как выходному столбцу всегда можно присвоить имя, воспользовавшись предложением AS.

В предложении ORDER BY также можно использовать произвольные выражения, в том числе, и со столбцами, отсутствующими в списке результатов SELECT. Таким образом, следующий оператор вполне корректен:

SELECT name FROM distributors ORDER BY code;
Однако, если ORDER BY применяется к результату UNION, INTERSECT или EXCEPT, в нём можно задать только имя или номер выходного столбца, но не выражение.

Если в качестве выражения ORDER BY задано простое имя, которому соответствует и выходной, и входной столбец, то ORDER BY будет воспринимать его как имя выходного столбца. Этот выбор противоположен тому, что делает GROUP BY в такой же ситуации. Такая несогласованность допущена для соответствия стандарту SQL.

Дополнительно после любого выражения в предложении ORDER BY можно добавить ключевое слово ASC (по возрастанию) или DESC (по убыванию). По умолчанию подразумевается ASC. Кроме того, можно задать имя специфического оператора сортировки в предложении USING. Оператор сортировки должен быть членом «меньше» или «больше» некоторого семейства операторов B-дерева. ASC обычно равнозначно USING < и DESC обычно равнозначно USING >. (Хотя создатель нестандартного типа данных может определить по-другому порядок сортировки по умолчанию и поставить ему в соответствие операторы с другими именами.)

Если указано NULLS LAST, значения NULL при сортировке оказываются после значений не NULL; с указанием NULLS FIRST значения NULL оказываются перед значениями не NULL. Если не указано ни то, ни другое, по умолчанию подразумевается NULLS LAST при явно или неявно выбранном порядке ASC, либо NULLS FIRST при порядке DESC (то есть по умолчанию считается, что значения NULL больше значений не NULL). С предложением USING порядок NULL по умолчанию зависит от того, является ли указанный оператор оператором «меньше» или «больше».

Заметьте, что параметры сортировки применяются только к тому выражению, за которым они следуют; в частности, ORDER BY x, y DESC означает не то же самое, что ORDER BY x DESC, y DESC.

Данные символьных строк сортируются согласно правилу сортировки, установленному для сортируемого столбца. При необходимости это правило можно переопределить, добавив предложение COLLATE в выражение, например так: ORDER BY mycolumn COLLATE "en_US". За дополнительными сведениями обратитесь к Подразделу 4.2.10 и 


****************************************************************************
## ORM 


****************************************************************************
### CRUD операции
*

****************************************************************************
### связи между моделями
*

****************************************************************************
### миграции
