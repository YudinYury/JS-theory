# Backend developer checklist (все по ООП, подчернутые в приоритете)

****************************************************************************
## Stage 1, part 2 
## ООП
Вопросы в этом разделе:
  * Шаблоны (понимание, обоснование применения): Издатель-подписчик (Publish–subscribe),  Одиночка, Фабричный метод, Абстрактная фабрика.
  * MVC - Отношения между моделью, вьюхой и контроллером.
  * СОЛИД, первые четыре принципа (поверхностное представление).

****************************************************************************

### **Объект** 
— это именованная сущность, одновременно содержащая данные(свойства) и поведения(методы).
Слово «одновременно» в данном случае определяет ключевую разницу между ООП и 
другими методологиями программирования. Например, при процедурном программировании 
код размещается в полностью отдельных функциях или процедурах.

**Класс** - это шаблон, предназначенный для создания объектов.
Класс - это именованная сущность из предметной области, возможно, имеющая 
предка (суперкласс), определенная как набор полей и методов.

В JavaScript классы можно организовать по-разному. Говорят, что класс User написан 
в «функциональном» стиле. Далее мы также увидим «прототипный» стиль.


****************************************************************************
### **Шаблоны (понимание, обоснование применения): Издатель-подписчик (Publish–subscribe), Одиночка, Фабричный метод, Абстрактная фабрика.**


#### ОДИНОЧКА-Синглтон
https://ru.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%BE%D1%87%D0%BA%D0%B0_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
Одиночка (англ. Singleton) — порождающий шаблон проектирования, гарантирующий, что в однопроцессном 
приложении будет единственный экземпляр некоторого класса, и предоставляющий глобальную точку доступа 
к этому экземпляру.
Использование синглтона не проблема, а признак проблемы. Вот две причины почему:
  - Программы, использующие глобальное состояние очень сложно протестировать;
  - Программы, которые зависят от глобального состояния, скрывают свои зависимости.

Цель применения Синглтон
У класса есть только один экземпляр, и он предоставляет к нему глобальную точку доступа. Существенно то, 
что можно пользоваться именно экземпляром класса, так как при этом во многих случаях становится доступной 
более широкая функциональность. Например, к описанным компонентам класса можно обращаться через интерфейс, 
если такая возможность поддерживается языком.

Глобальный «одинокий» объект — именно объект, а не набор процедур, не привязанных ни к какому 
объекту — бывает нужен:
  - если используется существующая объектно-ориентированная библиотека;
  - если есть шансы, что один объект когда-нибудь превратится в несколько;
  - если интерфейс объекта (например, игрового мира) слишком сложен и не стоит засорять основное пространство имён большим количеством функций;
  - если, в зависимости от каких-нибудь условий и настроек, создаётся один из нескольких объектов. Например, в зависимости от того, ведётся лог или нет, создаётся или настоящий объект, пишущий в файл, или «заглушка», ничего не делающая.
Такие объекты можно создавать и при инициализации программы. Это может приводить к следующим трудностям:
  - Если объект нужен уже при инициализации, он может быть затребован раньше, чем будет создан.
  - Бывает, что объект нужен не всегда. В таком случае его создание можно пропустить.

Плюсы:
  - контролируемый доступ к единственному экземпляру.

Минусы:
  - глобальные объекты могут быть вредны для объектного программирования, в некоторых случаях приводят к созданию немасштабируемого проекта;
  - усложняет написание модульных тестов и следование TDD.

```
const Singleton = (function() {
  let instance;

  // Приватные методы и свойства

  // Конструктор
  function Singleton() {
    if (instance) return instance;
    instance = this;
  }

  // Публичные методы
  Singleton.prototype.test = function() {};

  return Singleton;
})();

console.assert(new Singleton() === new Singleton());
```
Без использования сокрытия переменных есть простое решение, основанное на том, что функция Singleton является объектом. Минусом является возможность изменения св-ва instance вне класса:

```
function Singleton() {
  const instance = Singleton.instance;
  if (instance) return instance;
  Singleton.instance = this;
}

Singleton.prototype.test = function() {};

console.assert(new Singleton() === new Singleton());
```
Наиболее короткий вариант.
```
const Singleton = new (function() {
  const instance = this;
  return function() { return instance; };
})();

console.assert(new Singleton() === new Singleton());
```

#### это best practice !!!!!!!!!!!!!!!!!!!!!
```
function Singleton() {
    if (!Singleton.instance) { 
        Singleton.instance = this;
    }
    return Singleton.instance;  
}
```
СИЛЬНАЯ СВЯЗАННОСТЬ — это обобщение проблемы синглтона. Одним словом, вы должны уменьшить связь между 
своими модулями. Связанность — это мера того, насколько связаны подпрограммы или модули.
Если внесение изменения в одном модуле в вашем приложении требует, чтобы вы изменили другой модуль, 
тогда связанность существует. Например, вы инстанцируете объекты в классе своего конструктора вместо 
передачи экземпляров как параметров. Это плохо, потому что он не допускает дальнейших изменений, такие 
как замена экземпляра экземпляром подкласса, объектом-mock или что бы то ни было.
Сильно связанные модули трудно повторно использовать, и также сложно тестировать.

Преждевременная оптимизация
Дональд Кнут сказал: «преждевременная оптимизация — корень всех зол. Только одни затраты, и никакой 
пользы». Фактически, оптимизированные системы гораздо сложнее, чем просто написание цикла или 
использование преинкремента вместо постинкремента. В конечном итоге, вы останетесь с нечитабельным 
кодом. Именно поэтому Преждевременную Оптимизацию часто считают ошибочной.

паттерн ПОСРЕДНИК определяет интерфейс для обмена информацией с объектами "Коллеги", 
"Конкретный посредник" координирует действия объектов "Коллеги". Каждый класс "Коллеги" знает о своем 
объекте "Посредник", все "Коллеги" обмениваются информацией только с посредником, при его отсутствии 
им пришлось бы обмениваться информацией напрямую. "Коллеги" посылают запросы посреднику и получают 
запросы от него. "Посредник" реализует кооперативное поведение, пересылая каждый запрос одному или 
нескольким "Коллегам".

#### ФАБРИЧНЫЙ МЕТОД (шаблон проектирования)
(англ. Factory Method также известен как Виртуальный конструктор (англ. Virtual Constructor)) — 
порождающий шаблон проектирования, предоставляющий подклассам интерфейс для создания экземпляров 
некоторого класса. В момент создания наследники могут определить, какой класс создавать. 
Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, какой класс инстанцировать. 
Фабричный метод позволяет классу делегировать создание подклассов. Используется, когда:
  - родительскому классу заранее неизвестно, объекты каких подклассов ему нужно создавать.
  - класс спроектирован так, чтобы объекты, которые он создаёт, специфицировались подклассами.
  - класс делегирует свои обязанности одному из нескольких вспомогательных подклассов, и планируется 
  локализовать знание о том, какой класс принимает эти обязанности на себя

https://refactoring.guru/ru/design-patterns/factory-method

```
class Product { GetName() {} }

class ConcreteProductA extends Product { GetName() { return 'ProductA' } }
class ConcreteProductB extends Product { GetName() { return 'ProductB' } }
class Creator { FactoryMethod() {} }
class ConcreteCreatorA extends Creator { FactoryMethod() { return new ConcreteProductA() } }
class ConcreteCreatorB extends Creator { FactoryMethod() { return new ConcreteProductB() } }
// An array of creators
const creators = [ new ConcreteCreatorA(), new ConcreteCreatorB() ]
const products = []
// Iterate over creators and create products
for (let creator of creators) {
    products.push(creator.FactoryMethod().GetName())
}
console.log(products)
```
... и в новом варианте
```
interface SocialHubConnect { PushNewPost() {} }

class VkHTTP implements SocialHubConnect { PushNewPost(newPost) {  return axios.get(newPost); } }
class VkGraphQL implements SocialHubConnect { PushNewPost(newPost) { return axios.gql(newPost); } }
class FacebookGraphQL implements SocialHubConnect { 
    PushNewPost(newPost) { return axios.gql(newPost); } 
}

class FactoryCreator { public abstract SocialConnect() {} }

class HTTPFactoryCreator extends FactoryCreator { FactoryMethod() { return new VkHTTP() } }
class GraphQLFactoryCreator extends FactoryCreator { FactoryMethod() { return new VkGraphQL() } }
class GraphQLFacebookFactoryCreator extends FactoryCreator { 
  FactoryMethod() { return new FacebookGraphQL() } 
}

// An array of creators
const advertizingChannels = [ new HTTPFactoryCreator(), new GraphQLFactoryCreator(), 
        new GraphQLFacebookFactoryCreator() ]
// Iterate over creators and make newPost for all advertizing channels
for (let point of advertizingChannels) {
    point.SocialConnect().PushNewPost('newPost - Hello world');
}
```


#### АБСТРАКТНАЯ ФАБРИКА
https://refactoring.guru/ru/design-patterns/abstract-factory
https://refactoring.guru/ru/design-patterns/factory-comparison 

https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%B0%D1%8F_%D1%84%D0%B0%D0%B1%D1%80%D0%B8%D0%BA%D0%B0_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)

Абстрактная фабрика (англ. Abstract factory) — порождающий шаблон проектирования, предоставляет интерфейс 
для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов. 
Шаблон реализуется созданием абстрактного класса Factory, который представляет собой интерфейс для создания 
компонентов системы (например, для оконного интерфейса он может создавать окна и кнопки). Затем пишутся 
классы, реализующие этот интерфейс.

Предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя 
их конкретных классов.

Плюсы:
  - изолирует конкретные классы;
  - упрощает замену семейств продуктов;
  - гарантирует сочетаемость продуктов.

Минусы:
- сложно добавить поддержку нового вида продуктов.


****************************************************************************
### MVC - Отношения между моделью, вьюхой и контроллером.
*

Node js service view controller
#### CONTROLLER
Занимается рендером, работой с http запросом, отправкой ошибок на клиент, роутингом, версионированием, вызовом сервисов и вьюх
Не занимается бизнес логикой и преобразованием данных
#### VIEW
В данном контексте не типичная mvc view, а класс для преобразования данных для отправки на клиент
Занимается преобразованием json данных для отправки на клиент (удаление лишних полей, форматирование даты)
Не занимается бизнес логикой (фильтрация, сортировка)
#### SERVICE
Занимается бизнес логикой
Не занимается работой с HTTP (например сервис не может выбрасывать 403 статус на клиент)


****************************************************************************
### СОЛИД (SOLID), первые четыре принципа (поверхностное представление).
*
https://habr.com/post/273843/

#### SOLID — термин, описывающий набор принципов разработки для эффективного кода, который был изобретен 
Робертом К. Мартином, также известным как Uncle Bob.

SOLID значит:
  - Принцип единственной обязанности (Single-Responsibility Principle)
  - Принцип открытости/закрытости (Open/Closed Principle, OCP)
  - Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP)
  - Принцип разделения интерфейса (Interface Segregation Principle или ISP) 
  - Внедрение зависимостей (Dependency Injection/inversion или DI)

#### S — Single responsibility — Принцип единственной ответственности/обязанности
«На каждый объект должна быть возложена одна единственная обязанность». 
Т.е. другими словами — конкретный класс должен решать конкретную задачу — ни больше, ни меньше.
У класса должна быть только одна причина для изменения. 
Разделите большие классы на меньшие и избегайте “божественных” классов. Напишите простые комментарии. Если 
начинаете писать комментарии такие как in this case, but if, except when, or, то вы делаете это неправильно.

#### O — Open-closed — Принцип открытости/закрытости 
"программные сущности должны быть открыты для расширения, но закрыты для модификации". 
Т.е. все классы, функции и т.д. должны проектироваться так, чтобы для изменения их поведения, 
нам не нужно было изменять их исходный код.
Вы должны сделать все переменные экземпляра private по умолчанию. Пишите методы get и set 
только, когда они действительно будут вам нужны.

#### L — Liskov substitution — Принцип подстановки Барбары Лисков
«Объекты в программе могут быть заменены их наследниками без изменения свойств программы». Своими словами я бы это сказал так — при использовании наследника класса результат выполнения кода должен быть предсказуем и не изменять свойств метод.
Проектирование по контракту ведет к некоторым ограничениям на то, как контракты могут взаимодействовать с наследованием, а именно:
Предусловия не могут быть усилены в подклассе.
Постусловия не могут быть ослаблены в подклассе.
Предусловия – это то, что должно быть выполнено вызывающей стороной перед вызовом метода, постусловия – это то, что, гарантируется вызываемым методом.
Должна быть возможность вместо базового типа подставить любой его подтип.
Давайте рассмотрим пример. Прямоугольник — плоская фигура с четырьмя прямыми углами. У него есть ширина (width) 
и высота (height). 
Теперь, взгляните на следующий псевдо-код:

```
rect = new Rectangle();
rect.width  = 10;
rect.height = 20;
assert 10 == rect.width
assert 20 == rect.height
```

Мы просто устанавливаем ширину width и высоту height на экземпляре Rectangle, и затем мы подтверждаем, что оба 
свойства правильны. Пока все идет хорошо.

Теперь мы можем улучшить наше определение, сообщив, что прямоугольник с четырьмя сторонами одинаковой длины 
называют квадратом. Квадрат — это прямоугольник, таким образом, мы можем создать класс Square, который 
расширяет класс Rectangle, и заменить первую строку, представленную выше, нижней:
rect = new Square();

Согласно определению квадрата, его ширина равна его высоте. Вы можете определить проблему? Первое утверждение 
перестанет работать, потому что мы должны были изменить поведение методов set в классе Square, чтобы 
соответствовать определению. Это нарушение Принципа подстановки Барбары Лисков.

#### I — Interface segregation — Принцип разделения интерфейса 
«Много специализированных интерфейсов лучше, чем один универсальный»
Соблюдение этого принципа необходимо для того, чтобы классы-клиенты, использующий/реализующий интерфейс, 
знали только о тех методах, которые они используют, что ведёт к уменьшению количества неиспользуемого кода.
Вам не придется реализовать методы, которые вы не используете. 
Осуществление ISP дает слабую связанность и сильную связность.

Сильная связность означает сохранять подобные и связанные элементы вместе. Идея состоит в том, 
чтобы сохранить компоненты ориентированными, и попытаться минимизировать зависимости между ними.

Обратите внимание на то, что это подобно Принципу единственной обязанности (Single-Responsibility). 
Интерфейс — контракт, который удовлетворяет потребности. Нормально иметь класс, который реализует 
различные интерфейсы, но будьте осторожны, не нарушайте SRP.

#### D — Dependency Invertion — Принцип инверсии зависимостей 
«Зависимости внутри системы строятся на основе абстракций. Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций». Данное определение можно сократить — «зависимости должны строится относительно абстракций, а не деталей».

Этот принцип можно перефразировать, как использовать тот же уровень абстракции на заданном уровне. 
Интерфейсы должны зависеть от других интерфейсов. Не добавляйте конкретные классы к сигнатурам методов интерфейса. 
Однако используйте интерфейсы в своих методах класса.

Обратите внимание на то, что Принцип инверсии зависимостей не совпадает с Внедрением зависимостей. 
Внедрение зависимости это когда один объект знает о другом зависимом объекте. Иными словами, речь идет о том, 
как один объект получает зависимость. С другой стороны, Принцип внедрение зависимости заключается в уровне 
абстракции. Кроме того, контейнер внедрения зависимости — это способ для автоматического соединения классов. 
Это не означает, что вы делаете внедрение зависимости все же. Например, взгляните на Service Locator.

Также, вместо того, чтобы работать с классами, которые являются сильно связанными, используйте интерфейсы. 
Это называется программирование интерфейса. Он уменьшает зависимость от особенностей реализации и допускает повторное использование кода. Он также гарантирует, что Вы сможете заменить реализацию, не нарушая ожидания того интерфейса, согласно Принципу подстановки Барбары Лисков.


****************************************************************************
### ОБОБЩЕНИЕ-КОНКРЕТИЗАЦИЯ
*
Идея заключается в том, что по мере того как вы спускаетесь по дереву наследования,
все становится более конкретным. Самое общее располагается на верхушке дере­
ва наследования. Если рассматривать наше дерево наследования Dog , класс с аналогичным названием располагается на 
его верхушке и является наиболее общей категорией. 
Разные породы — классы GoldenRetriever , LhasaApso и Basenji — являются наиболее конкретными. Идея наследования состоит в том, чтобы переходить от общего к частному, выделяя общность.


****************************************************************************
### Проектирование
*
Этапы:
1) Составление технического задания - должно обеспечить полное понимание системы для любого человека
2) Определение классов - самый простой способ определить классы — выделить все существительные.
проектирование является итеративным процессом
3) Определение ответственности каждого класса - Сюда входят данные, которые должен содержать класс, 
а также операции, которые он должен выполнять.
4) Определение взаимодействия классов друг с другом
менно здесь находят свое применение со-
общения между классами. Один класс может отправить сообщение другому, когда
ему нужна информация из этого класса либо требуется, чтобы другой класс что-то
сделал для него.
5) Создание модели классов для описания системы
Модель классов показывает, как разные классы взаимодействуют в рамках
системы.
6) Прототипирование интерфейса пользователя
7) Структурированный код
Три базовые концепции структурного программирования: последовательность, условия
и итерации.
В ООП: Объект -> метод -> структурированный код

Разработчики программного обеспечения часто применяют код, написанный
кем-то другим. Это может быть код, приобретенный у поставщика или даже на-
писанный людьми из той же организации. Во многих случаях оказывается, что код
нельзя изменить. Возможно, из-за того, что человек, написавший код, больше не
работает в организации либо поставщик не может предоставить пакеты обновлений
и т. д. Именно в таких ситуациях проявляется истинная мощь оберток.


